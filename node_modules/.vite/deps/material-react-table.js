import {
  require_createSvgIcon,
  require_interopRequireDefault
} from "./chunk-FUKXB2G4.js";
import {
  AlertTitle_default,
  Alert_default,
  Box_default,
  Checkbox_default,
  Chip_default,
  Collapse_default,
  DialogActions_default,
  DialogContent_default,
  DialogTitle_default,
  Dialog_default,
  Divider_default,
  FormControlLabel_default,
  IconButton_default,
  InputAdornment_default,
  LinearProgress_default,
  ListItemIcon_default,
  MenuItem_default,
  Radio_default,
  Skeleton_default,
  Stack_default,
  Switch_default,
  TableBody_default,
  TableCell_default,
  TableContainer_default,
  TableFooter_default,
  TableHead_default,
  TablePagination_default,
  TableRow_default,
  TableSortLabel_default,
  Table_default,
  Toolbar_default,
  Tooltip_default,
  Typography_default,
  useMediaQuery
} from "./chunk-PZQXLUUM.js";
import {
  Fade_default,
  Grow_default,
  Menu_default,
  Paper_default,
  TextField_default,
  useTheme
} from "./chunk-MCBVCEBD.js";
import "./chunk-6D22WKM3.js";
import "./chunk-6L62X2UX.js";
import {
  Button_default
} from "./chunk-Z5WVLDTQ.js";
import "./chunk-XQL7Y3FQ.js";
import "./chunk-RRZDWW7X.js";
import "./chunk-SMMHVOWJ.js";
import "./chunk-VFCKLIQH.js";
import {
  alpha,
  darken,
  esm_exports,
  init_esm,
  lighten
} from "./chunk-CB4YA6PQ.js";
import "./chunk-PXZMQBN5.js";
import {
  require_jsx_runtime
} from "./chunk-NHJI5CSF.js";
import {
  require_react
} from "./chunk-M45RNPIH.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@mui/icons-material/ArrowDownward.js
var require_ArrowDownward = __commonJS({
  "node_modules/@mui/icons-material/ArrowDownward.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
    }), "ArrowDownward");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ArrowRight.js
var require_ArrowRight = __commonJS({
  "node_modules/@mui/icons-material/ArrowRight.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m10 17 5-5-5-5v10z"
    }), "ArrowRight");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/@mui/icons-material/Cancel.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), "Cancel");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/CheckBox.js
var require_CheckBox = __commonJS({
  "node_modules/@mui/icons-material/CheckBox.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
    }), "CheckBox");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ClearAll.js
var require_ClearAll = __commonJS({
  "node_modules/@mui/icons-material/ClearAll.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z"
    }), "ClearAll");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Close.js
var require_Close = __commonJS({
  "node_modules/@mui/icons-material/Close.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensityLarge.js
var require_DensityLarge = __commonJS({
  "node_modules/@mui/icons-material/DensityLarge.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3z"
    }), "DensityLarge");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensityMedium.js
var require_DensityMedium = __commonJS({
  "node_modules/@mui/icons-material/DensityMedium.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3zm0-8h18v2H3z"
    }), "DensityMedium");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensitySmall.js
var require_DensitySmall = __commonJS({
  "node_modules/@mui/icons-material/DensitySmall.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 2h18v2H3zm0 18h18v2H3zm0-6h18v2H3zm0-6h18v2H3z"
    }), "DensitySmall");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DragHandle.js
var require_DragHandle = __commonJS({
  "node_modules/@mui/icons-material/DragHandle.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M20 9H4v2h16V9zM4 15h16v-2H4v2z"
    }), "DragHandle");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DynamicFeed.js
var require_DynamicFeed = __commonJS({
  "node_modules/@mui/icons-material/DynamicFeed.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M8 8H6v7c0 1.1.9 2 2 2h9v-2H8V8z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M20 3h-8c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 8h-8V7h8v4zM4 12H2v7c0 1.1.9 2 2 2h9v-2H4v-7z"
    }, "1")], "DynamicFeed");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Edit.js
var require_Edit = __commonJS({
  "node_modules/@mui/icons-material/Edit.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
    }), "Edit");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ExpandLess.js
var require_ExpandLess = __commonJS({
  "node_modules/@mui/icons-material/ExpandLess.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
    }), "ExpandLess");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ExpandMore.js
var require_ExpandMore = __commonJS({
  "node_modules/@mui/icons-material/ExpandMore.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
    }), "ExpandMore");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterAlt.js
var require_FilterAlt = __commonJS({
  "node_modules/@mui/icons-material/FilterAlt.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
    }), "FilterAlt");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterAltOff.js
var require_FilterAltOff = __commonJS({
  "node_modules/@mui/icons-material/FilterAltOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M19.79 5.61C20.3 4.95 19.83 4 19 4H6.83l7.97 7.97 4.99-6.36zM2.81 2.81 1.39 4.22 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2.17l5.78 5.78 1.41-1.41L2.81 2.81z"
    }), "FilterAltOff");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterList.js
var require_FilterList = __commonJS({
  "node_modules/@mui/icons-material/FilterList.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
    }), "FilterList");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterListOff.js
var require_FilterListOff = __commonJS({
  "node_modules/@mui/icons-material/FilterListOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M10.83 8H21V6H8.83l2 2zm5 5H18v-2h-4.17l2 2zM14 16.83V18h-4v-2h3.17l-3-3H6v-2h2.17l-3-3H3V6h.17L1.39 4.22 2.8 2.81l18.38 18.38-1.41 1.41L14 16.83z"
    }), "FilterListOff");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FullscreenExit.js
var require_FullscreenExit = __commonJS({
  "node_modules/@mui/icons-material/FullscreenExit.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"
    }), "FullscreenExit");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Fullscreen.js
var require_Fullscreen = __commonJS({
  "node_modules/@mui/icons-material/Fullscreen.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"
    }), "Fullscreen");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js
var require_KeyboardDoubleArrowDown = __commonJS({
  "node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M18 6.41 16.59 5 12 9.58 7.41 5 6 6.41l6 6z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "m18 13-1.41-1.41L12 16.17l-4.59-4.58L6 13l6 6z"
    }, "1")], "KeyboardDoubleArrowDown");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/MoreHoriz.js
var require_MoreHoriz = __commonJS({
  "node_modules/@mui/icons-material/MoreHoriz.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
    }), "MoreHoriz");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/MoreVert.js
var require_MoreVert = __commonJS({
  "node_modules/@mui/icons-material/MoreVert.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
    }), "MoreVert");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/PushPin.js
var require_PushPin = __commonJS({
  "node_modules/@mui/icons-material/PushPin.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      fillRule: "evenodd",
      d: "M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1 1-1v-7H19v-2c-1.66 0-3-1.34-3-3z"
    }), "PushPin");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/RestartAlt.js
var require_RestartAlt = __commonJS({
  "node_modules/@mui/icons-material/RestartAlt.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91z"
    }), "RestartAlt");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Save.js
var require_Save = __commonJS({
  "node_modules/@mui/icons-material/Save.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
    }), "Save");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Search.js
var require_Search = __commonJS({
  "node_modules/@mui/icons-material/Search.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
    }), "Search");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/SearchOff.js
var require_SearchOff = __commonJS({
  "node_modules/@mui/icons-material/SearchOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3 6.08 3 3.28 5.64 3.03 9h2.02C5.3 6.75 7.18 5 9.5 5 11.99 5 14 7.01 14 9.5S11.99 14 9.5 14c-.17 0-.33-.03-.5-.05v2.02c.17.02.33.03.5.03 1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M6.47 10.82 4 13.29l-2.47-2.47-.71.71L3.29 14 .82 16.47l.71.71L4 14.71l2.47 2.47.71-.71L4.71 14l2.47-2.47z"
    }, "1")], "SearchOff");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Sort.js
var require_Sort = __commonJS({
  "node_modules/@mui/icons-material/Sort.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"
    }), "Sort");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ViewColumn.js
var require_ViewColumn = __commonJS({
  "node_modules/@mui/icons-material/ViewColumn.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M14.67 5v14H9.33V5h5.34zm1 14H21V5h-5.33v14zm-7.34 0V5H3v14h5.33z"
    }), "ViewColumn");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/VisibilityOff.js
var require_VisibilityOff = __commonJS({
  "node_modules/@mui/icons-material/VisibilityOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
    }), "VisibilityOff");
    exports.default = _default;
  }
});

// node_modules/@mui/material/utils/debounce.js
var require_debounce = __commonJS({
  "node_modules/@mui/material/utils/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _utils = (init_esm(), __toCommonJS(esm_exports));
    var _default = _utils.unstable_debounce;
    exports.default = _default;
  }
});

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
var import_react2 = __toESM(require_react());

// node_modules/@tanstack/react-table/build/esm/index.js
var React = __toESM(require_react());
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return () => {
    let depTime;
    if (opts.key && opts.debug)
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug)
      resultTime = Date.now();
    result = fn(...newDeps);
    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function createColumn(table, columnDef, depth, parent) {
  var _a, _b;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_b = (_a = resolvedColumnDef.id) != null ? _a : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _b : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          result = result[key];
          if (result === void 0) {
            throw new Error(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
    }, {
      key: false,
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    }),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, {
      key: false,
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    })
  };
  column = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, table));
  }, column);
  return column;
}
function createHeader(table, column, options) {
  var _a;
  const id = (_a = options.id) != null ? _a : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, table));
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    return {
      getHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        var _a, _b;
        const leftColumns = (_a = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _a : [];
        const rightColumns = (_b = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _b : [];
        const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
        return headerGroups;
      }, {
        key: "getHeaderGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getCenterHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        return buildHeaderGroups(allColumns, leafColumns, table, "center");
      }, {
        key: "getCenterHeaderGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getLeftHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
        var _a;
        const orderedLeafColumns = (_a = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _a : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
      }, {
        key: "getLeftHeaderGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getRightHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
        var _a;
        const orderedLeafColumns = (_a = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _a : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
      }, {
        key: "getRightHeaderGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getFooterGroups: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getFooterGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getLeftFooterGroups: memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getLeftFooterGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getCenterFooterGroups: memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getCenterFooterGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getRightFooterGroups: memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getRightFooterGroups",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getFlatHeaders: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return headerGroups.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getFlatHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getLeftFlatHeaders: memo(() => [table.getLeftHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getLeftFlatHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getCenterFlatHeaders: memo(() => [table.getCenterHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getCenterFlatHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getRightFlatHeaders: memo(() => [table.getRightHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getRightFlatHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getCenterLeafHeaders: memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders;
          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
        });
      }, {
        key: "getCenterLeafHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getLeftLeafHeaders: memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders2;
          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
        });
      }, {
        key: "getLeftLeafHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getRightLeafHeaders: memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders3;
          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
        });
      }, {
        key: "getRightLeafHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      }),
      getLeafHeaders: memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
        var _a, _b, _c;
        var _left$, _center$, _right$;
        return [...(_a = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _a : [], ...(_b = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _b : [], ...(_c = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _c : []].map((header) => {
          return header.getLeafHeaders();
        }).flat();
      }, {
        key: "getLeafHeaders",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugHeaders;
        }
      })
    };
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _a;
  var _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_a = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _a : []);
  return headerGroups;
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    return {
      getSize: () => {
        var _a, _b, _c;
        const columnSize = table.getState().columnSizing[column.id];
        return Math.min(Math.max((_a = column.columnDef.minSize) != null ? _a : defaultColumnSizing.minSize, (_b = columnSize != null ? columnSize : column.columnDef.size) != null ? _b : defaultColumnSizing.size), (_c = column.columnDef.maxSize) != null ? _c : defaultColumnSizing.maxSize);
      },
      getStart: (position) => {
        const columns = !position ? table.getVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
        const index = columns.findIndex((d) => d.id === column.id);
        if (index > 0) {
          const prevSiblingColumn = columns[index - 1];
          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();
        }
        return 0;
      },
      resetSize: () => {
        table.setColumnSizing((_ref) => {
          let {
            [column.id]: _,
            ...rest
          } = _ref;
          return rest;
        });
      },
      getCanResize: () => {
        var _a, _b;
        return ((_a = column.columnDef.enableResizing) != null ? _a : true) && ((_b = table.options.enableColumnResizing) != null ? _b : true);
      },
      getIsResizing: () => {
        return table.getState().columnSizingInfo.isResizingColumn === column.id;
      }
    };
  },
  createHeader: (header, table) => {
    return {
      getSize: () => {
        let sum2 = 0;
        const recurse = (header2) => {
          var _a;
          if (header2.subHeaders.length) {
            header2.subHeaders.forEach(recurse);
          } else {
            sum2 += (_a = header2.column.getSize()) != null ? _a : 0;
          }
        };
        recurse(header);
        return sum2;
      },
      getStart: () => {
        if (header.index > 0) {
          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
        }
        return 0;
      },
      getResizeHandler: () => {
        const column = table.getColumn(header.column.id);
        const canResize = column.getCanResize();
        return (e) => {
          if (!canResize) {
            return;
          }
          e.persist == null ? void 0 : e.persist();
          if (isTouchStartEvent(e)) {
            if (e.touches && e.touches.length > 1) {
              return;
            }
          }
          const startSize = header.getSize();
          const columnSizingStart = header ? header.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
          const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
          const updateOffset = (eventType, clientXPos) => {
            if (typeof clientXPos !== "number") {
              return;
            }
            let newColumnSizing = {};
            table.setColumnSizingInfo((old) => {
              var _a, _b;
              const deltaOffset = clientXPos - ((_a = old == null ? void 0 : old.startOffset) != null ? _a : 0);
              const deltaPercentage = Math.max(deltaOffset / ((_b = old == null ? void 0 : old.startSize) != null ? _b : 0), -0.999999);
              old.columnSizingStart.forEach((_ref2) => {
                let [columnId, headerSize] = _ref2;
                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
              });
              return {
                ...old,
                deltaOffset,
                deltaPercentage
              };
            });
            if (table.options.columnResizeMode === "onChange" || eventType === "end") {
              table.setColumnSizing((old) => ({
                ...old,
                ...newColumnSizing
              }));
            }
          };
          const onMove = (clientXPos) => updateOffset("move", clientXPos);
          const onEnd = (clientXPos) => {
            updateOffset("end", clientXPos);
            table.setColumnSizingInfo((old) => ({
              ...old,
              isResizingColumn: false,
              startOffset: null,
              startSize: null,
              deltaOffset: null,
              deltaPercentage: null,
              columnSizingStart: []
            }));
          };
          const mouseEvents = {
            moveHandler: (e2) => onMove(e2.clientX),
            upHandler: (e2) => {
              document.removeEventListener("mousemove", mouseEvents.moveHandler);
              document.removeEventListener("mouseup", mouseEvents.upHandler);
              onEnd(e2.clientX);
            }
          };
          const touchEvents = {
            moveHandler: (e2) => {
              if (e2.cancelable) {
                e2.preventDefault();
                e2.stopPropagation();
              }
              onMove(e2.touches[0].clientX);
              return false;
            },
            upHandler: (e2) => {
              var _e$touches$;
              document.removeEventListener("touchmove", touchEvents.moveHandler);
              document.removeEventListener("touchend", touchEvents.upHandler);
              if (e2.cancelable) {
                e2.preventDefault();
                e2.stopPropagation();
              }
              onEnd((_e$touches$ = e2.touches[0]) == null ? void 0 : _e$touches$.clientX);
            }
          };
          const passiveIfSupported = passiveEventSupported() ? {
            passive: false
          } : false;
          if (isTouchStartEvent(e)) {
            document.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
            document.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
          } else {
            document.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
            document.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
          }
          table.setColumnSizingInfo((old) => ({
            ...old,
            startOffset: clientX,
            startSize,
            deltaOffset: 0,
            deltaPercentage: 0,
            columnSizingStart,
            isResizingColumn: column.id
          }));
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setColumnSizing: (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater),
      setColumnSizingInfo: (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater),
      resetColumnSizing: (defaultState) => {
        var _a;
        table.setColumnSizing(defaultState ? {} : (_a = table.initialState.columnSizing) != null ? _a : {});
      },
      resetHeaderSizeInfo: (defaultState) => {
        var _a;
        table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_a = table.initialState.columnSizingInfo) != null ? _a : getDefaultColumnSizingInfoState());
      },
      getTotalSize: () => {
        var _a;
        var _table$getHeaderGroup;
        return (_a = (_table$getHeaderGroup = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a : 0;
      },
      getLeftTotalSize: () => {
        var _a;
        var _table$getLeftHeaderG;
        return (_a = (_table$getLeftHeaderG = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a : 0;
      },
      getCenterTotalSize: () => {
        var _a;
        var _table$getCenterHeade;
        return (_a = (_table$getCenterHeade = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a : 0;
      },
      getRightTotalSize: () => {
        var _a;
        var _table$getRightHeader;
        return (_a = (_table$getRightHeader = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a : 0;
      }
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean")
    return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === "touchstart";
}
var Expanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetExpanded: () => {
        var _a, _b;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_b = (_a = table.options.autoResetAll) != null ? _a : table.options.autoResetExpanded) != null ? _b : !table.options.manualExpanding) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetExpanded();
            queued = false;
          });
        }
      },
      setExpanded: (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater),
      toggleAllRowsExpanded: (expanded) => {
        if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
          table.setExpanded(true);
        } else {
          table.setExpanded({});
        }
      },
      resetExpanded: (defaultState) => {
        var _a;
        var _table$initialState;
        table.setExpanded(defaultState ? {} : (_a = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _a : {});
      },
      getCanSomeRowsExpand: () => {
        return table.getRowModel().flatRows.some((row) => row.getCanExpand());
      },
      getToggleAllRowsExpandedHandler: () => {
        return (e) => {
          e.persist == null ? void 0 : e.persist();
          table.toggleAllRowsExpanded();
        };
      },
      getIsSomeRowsExpanded: () => {
        const expanded = table.getState().expanded;
        return expanded === true || Object.values(expanded).some(Boolean);
      },
      getIsAllRowsExpanded: () => {
        const expanded = table.getState().expanded;
        if (typeof expanded === "boolean") {
          return expanded === true;
        }
        if (!Object.keys(expanded).length) {
          return false;
        }
        if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
          return false;
        }
        return true;
      },
      getExpandedDepth: () => {
        let maxDepth = 0;
        const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
        rowIds.forEach((id) => {
          const splitId = id.split(".");
          maxDepth = Math.max(maxDepth, splitId.length);
        });
        return maxDepth;
      },
      getPreExpandedRowModel: () => table.getSortedRowModel(),
      getExpandedRowModel: () => {
        if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
          table._getExpandedRowModel = table.options.getExpandedRowModel(table);
        }
        if (table.options.manualExpanding || !table._getExpandedRowModel) {
          return table.getPreExpandedRowModel();
        }
        return table._getExpandedRowModel();
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleExpanded: (expanded) => {
        table.setExpanded((old) => {
          const exists = old === true ? true : !!(old != null && old[row.id]);
          let oldExpanded = {};
          if (old === true) {
            Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
              oldExpanded[rowId] = true;
            });
          } else {
            oldExpanded = old;
          }
          expanded = expanded != null ? expanded : !exists;
          if (!exists && expanded) {
            return {
              ...oldExpanded,
              [row.id]: true
            };
          }
          if (exists && !expanded) {
            const {
              [row.id]: _,
              ...rest
            } = oldExpanded;
            return rest;
          }
          return old;
        });
      },
      getIsExpanded: () => {
        var _a;
        const expanded = table.getState().expanded;
        return !!((_a = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _a : expanded === true || expanded != null && expanded[row.id]);
      },
      getCanExpand: () => {
        var _a, _b;
        var _row$subRows;
        return (_b = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _b : ((_a = table.options.enableExpanding) != null ? _a : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      },
      getToggleExpandedHandler: () => {
        const canExpand = row.getCanExpand();
        return () => {
          if (!canExpand)
            return;
          row.toggleExpanded();
        };
      }
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _row$getValue;
  const search = filterValue.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null ? void 0 : _row$getValue.toLowerCase().includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null ? void 0 : _row$getValue3.toLowerCase()) === filterValue.toLowerCase();
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var Filters = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      globalFilter: void 0,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      filterFromLeafRows: false,
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode, _table$getCoreRowMode2;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null ? void 0 : (_table$getCoreRowMode2 = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode2.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoFilterFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return filterFns.includesString;
        }
        if (typeof value === "number") {
          return filterFns.inNumberRange;
        }
        if (typeof value === "boolean") {
          return filterFns.equals;
        }
        if (value !== null && typeof value === "object") {
          return filterFns.equals;
        }
        if (Array.isArray(value)) {
          return filterFns.arrIncludes;
        }
        return filterFns.weakEquals;
      },
      getFilterFn: () => {
        var _a;
        var _table$options$filter;
        return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (_a = (_table$options$filter = table.options.filterFns) == null ? void 0 : _table$options$filter[column.columnDef.filterFn]) != null ? _a : filterFns[column.columnDef.filterFn];
      },
      getCanFilter: () => {
        var _a, _b, _c;
        return ((_a = column.columnDef.enableColumnFilter) != null ? _a : true) && ((_b = table.options.enableColumnFilters) != null ? _b : true) && ((_c = table.options.enableFilters) != null ? _c : true) && !!column.accessorFn;
      },
      getCanGlobalFilter: () => {
        var _a, _b, _c, _d;
        return ((_a = column.columnDef.enableGlobalFilter) != null ? _a : true) && ((_b = table.options.enableGlobalFilter) != null ? _b : true) && ((_c = table.options.enableFilters) != null ? _c : true) && ((_d = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _d : true) && !!column.accessorFn;
      },
      getIsFiltered: () => column.getFilterIndex() > -1,
      getFilterValue: () => {
        var _table$getState$colum, _table$getState$colum2;
        return (_table$getState$colum = table.getState().columnFilters) == null ? void 0 : (_table$getState$colum2 = _table$getState$colum.find((d) => d.id === column.id)) == null ? void 0 : _table$getState$colum2.value;
      },
      getFilterIndex: () => {
        var _a;
        var _table$getState$colum3;
        return (_a = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d) => d.id === column.id)) != null ? _a : -1;
      },
      setFilterValue: (value) => {
        table.setColumnFilters((old) => {
          var _a, _b;
          const filterFn = column.getFilterFn();
          const previousfilter = old == null ? void 0 : old.find((d) => d.id === column.id);
          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : void 0);
          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
            return (_a = old == null ? void 0 : old.filter((d) => d.id !== column.id)) != null ? _a : [];
          }
          const newFilterObj = {
            id: column.id,
            value: newFilter
          };
          if (previousfilter) {
            return (_b = old == null ? void 0 : old.map((d) => {
              if (d.id === column.id) {
                return newFilterObj;
              }
              return d;
            })) != null ? _b : [];
          }
          if (old != null && old.length) {
            return [...old, newFilterObj];
          }
          return [newFilterObj];
        });
      },
      _getFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id),
      getFacetedRowModel: () => {
        if (!column._getFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return column._getFacetedRowModel();
      },
      _getFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id),
      getFacetedUniqueValues: () => {
        if (!column._getFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return column._getFacetedUniqueValues();
      },
      _getFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id),
      getFacetedMinMaxValues: () => {
        if (!column._getFacetedMinMaxValues) {
          return void 0;
        }
        return column._getFacetedMinMaxValues();
      }
    };
  },
  createRow: (row, table) => {
    return {
      columnFilters: {},
      columnFiltersMeta: {}
    };
  },
  createTable: (table) => {
    return {
      getGlobalAutoFilterFn: () => {
        return filterFns.includesString;
      },
      getGlobalFilterFn: () => {
        var _a;
        var _table$options$filter2;
        const {
          globalFilterFn
        } = table.options;
        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_a = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _a : filterFns[globalFilterFn];
      },
      setColumnFilters: (updater) => {
        const leafColumns = table.getAllLeafColumns();
        const updateFn = (old) => {
          var _functionalUpdate;
          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
            const column = leafColumns.find((d) => d.id === filter.id);
            if (column) {
              const filterFn = column.getFilterFn();
              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
                return false;
              }
            }
            return true;
          });
        };
        table.options.onColumnFiltersChange == null ? void 0 : table.options.onColumnFiltersChange(updateFn);
      },
      setGlobalFilter: (updater) => {
        table.options.onGlobalFilterChange == null ? void 0 : table.options.onGlobalFilterChange(updater);
      },
      resetGlobalFilter: (defaultState) => {
        table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
      },
      resetColumnFilters: (defaultState) => {
        var _a;
        var _table$initialState;
        table.setColumnFilters(defaultState ? [] : (_a = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _a : []);
      },
      getPreFilteredRowModel: () => table.getCoreRowModel(),
      getFilteredRowModel: () => {
        if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
          table._getFilteredRowModel = table.options.getFilteredRowModel(table);
        }
        if (table.options.manualFiltering || !table._getFilteredRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getFilteredRowModel();
      },
      _getGlobalFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__"),
      getGlobalFacetedRowModel: () => {
        if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getGlobalFacetedRowModel();
      },
      _getGlobalFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__"),
      getGlobalFacetedUniqueValues: () => {
        if (!table._getGlobalFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return table._getGlobalFacetedUniqueValues();
      },
      _getGlobalFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__"),
      getGlobalFacetedMinMaxValues: () => {
        if (!table._getGlobalFacetedMinMaxValues) {
          return;
        }
        return table._getGlobalFacetedMinMaxValues();
      }
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
var max = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
var extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value)
          min2 = max2 = value;
      } else {
        if (min2 > value)
          min2 = value;
        if (max2 < value)
          max2 = value;
      }
    }
  });
  return [min2, max2];
};
var mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2)
    return sum2 / count2;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  let min2 = 0;
  let max2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (typeof value === "number") {
      min2 = Math.min(min2, value);
      max2 = Math.max(max2, value);
    }
  });
  return (min2 + max2) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
var Grouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props2) => {
        var _a;
        var _props$getValue;
        return (_a = (_props$getValue = props2.getValue()) == null ? void 0 : _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _a : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    return {
      toggleGrouping: () => {
        table.setGrouping((old) => {
          if (old != null && old.includes(column.id)) {
            return old.filter((d) => d !== column.id);
          }
          return [...old != null ? old : [], column.id];
        });
      },
      getCanGroup: () => {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = column.columnDef.enableGrouping) != null ? _a : true) != null ? _b : table.options.enableGrouping) != null ? _c : true) != null ? _d : !!column.accessorFn;
      },
      getIsGrouped: () => {
        var _table$getState$group;
        return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
      },
      getGroupedIndex: () => {
        var _table$getState$group2;
        return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
      },
      getToggleGroupingHandler: () => {
        const canGroup = column.getCanGroup();
        return () => {
          if (!canGroup)
            return;
          column.toggleGrouping();
        };
      },
      getAutoAggregationFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "number") {
          return aggregationFns.sum;
        }
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return aggregationFns.extent;
        }
      },
      getAggregationFn: () => {
        var _a;
        var _table$options$aggreg;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_a = (_table$options$aggreg = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg[column.columnDef.aggregationFn]) != null ? _a : aggregationFns[column.columnDef.aggregationFn];
      }
    };
  },
  createTable: (table) => {
    return {
      setGrouping: (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater),
      resetGrouping: (defaultState) => {
        var _a;
        var _table$initialState;
        table.setGrouping(defaultState ? [] : (_a = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _a : []);
      },
      getPreGroupedRowModel: () => table.getFilteredRowModel(),
      getGroupedRowModel: () => {
        if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
          table._getGroupedRowModel = table.options.getGroupedRowModel(table);
        }
        if (table.options.manualGrouping || !table._getGroupedRowModel) {
          return table.getPreGroupedRowModel();
        }
        return table._getGroupedRowModel();
      }
    };
  },
  createRow: (row) => {
    return {
      getIsGrouped: () => !!row.groupingColumnId,
      _groupingValuesCache: {}
    };
  },
  createCell: (cell, column, row, table) => {
    return {
      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,
      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),
      getIsAggregated: () => {
        var _row$subRows;
        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      }
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var Ordering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createTable: (table) => {
    return {
      setColumnOrder: (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater),
      resetColumnOrder: (defaultState) => {
        var _a;
        table.setColumnOrder(defaultState ? [] : (_a = table.initialState.columnOrder) != null ? _a : []);
      },
      _getOrderColumnsFn: memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
        let orderedColumns = [];
        if (!(columnOrder != null && columnOrder.length)) {
          orderedColumns = columns;
        } else {
          const columnOrderCopy = [...columnOrder];
          const columnsCopy = [...columns];
          while (columnsCopy.length && columnOrderCopy.length) {
            const targetColumnId = columnOrderCopy.shift();
            const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
            if (foundIndex > -1) {
              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
            }
          }
          orderedColumns = [...orderedColumns, ...columnsCopy];
        }
        return orderColumns(orderedColumns, grouping, groupedColumnMode);
      }, {
        key: "getOrderColumnsFn"
      })
    };
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var Pagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetPageIndex: () => {
        var _a, _b;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_b = (_a = table.options.autoResetAll) != null ? _a : table.options.autoResetPageIndex) != null ? _b : !table.options.manualPagination) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetPageIndex();
            queued = false;
          });
        }
      },
      setPagination: (updater) => {
        const safeUpdater = (old) => {
          let newState = functionalUpdate(updater, old);
          return newState;
        };
        return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
      },
      resetPagination: (defaultState) => {
        var _a;
        table.setPagination(defaultState ? getDefaultPaginationState() : (_a = table.initialState.pagination) != null ? _a : getDefaultPaginationState());
      },
      setPageIndex: (updater) => {
        table.setPagination((old) => {
          let pageIndex = functionalUpdate(updater, old.pageIndex);
          const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
          pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
          return {
            ...old,
            pageIndex
          };
        });
      },
      resetPageIndex: (defaultState) => {
        var _a;
        var _table$initialState, _table$initialState$p;
        table.setPageIndex(defaultState ? defaultPageIndex : (_a = (_table$initialState = table.initialState) == null ? void 0 : (_table$initialState$p = _table$initialState.pagination) == null ? void 0 : _table$initialState$p.pageIndex) != null ? _a : defaultPageIndex);
      },
      resetPageSize: (defaultState) => {
        var _a;
        var _table$initialState2, _table$initialState2$;
        table.setPageSize(defaultState ? defaultPageSize : (_a = (_table$initialState2 = table.initialState) == null ? void 0 : (_table$initialState2$ = _table$initialState2.pagination) == null ? void 0 : _table$initialState2$.pageSize) != null ? _a : defaultPageSize);
      },
      setPageSize: (updater) => {
        table.setPagination((old) => {
          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
          const topRowIndex = old.pageSize * old.pageIndex;
          const pageIndex = Math.floor(topRowIndex / pageSize);
          return {
            ...old,
            pageIndex,
            pageSize
          };
        });
      },
      setPageCount: (updater) => table.setPagination((old) => {
        var _a;
        let newPageCount = functionalUpdate(updater, (_a = table.options.pageCount) != null ? _a : -1);
        if (typeof newPageCount === "number") {
          newPageCount = Math.max(-1, newPageCount);
        }
        return {
          ...old,
          pageCount: newPageCount
        };
      }),
      getPageOptions: memo(() => [table.getPageCount()], (pageCount) => {
        let pageOptions = [];
        if (pageCount && pageCount > 0) {
          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
        }
        return pageOptions;
      }, {
        key: "getPageOptions",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
        }
      }),
      getCanPreviousPage: () => table.getState().pagination.pageIndex > 0,
      getCanNextPage: () => {
        const {
          pageIndex
        } = table.getState().pagination;
        const pageCount = table.getPageCount();
        if (pageCount === -1) {
          return true;
        }
        if (pageCount === 0) {
          return false;
        }
        return pageIndex < pageCount - 1;
      },
      previousPage: () => {
        return table.setPageIndex((old) => old - 1);
      },
      nextPage: () => {
        return table.setPageIndex((old) => {
          return old + 1;
        });
      },
      getPrePaginationRowModel: () => table.getExpandedRowModel(),
      getPaginationRowModel: () => {
        if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
          table._getPaginationRowModel = table.options.getPaginationRowModel(table);
        }
        if (table.options.manualPagination || !table._getPaginationRowModel) {
          return table.getPrePaginationRowModel();
        }
        return table._getPaginationRowModel();
      },
      getPageCount: () => {
        var _a;
        return (_a = table.options.pageCount) != null ? _a : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);
      }
    };
  }
};
var getDefaultPinningState = () => ({
  left: [],
  right: []
});
var Pinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    return {
      pin: (position) => {
        const columnIds = column.getLeafColumns().map((d) => d.id).filter(Boolean);
        table.setColumnPinning((old) => {
          var _a, _b, _c, _d, _e, _f;
          if (position === "right") {
            return {
              left: ((_a = old == null ? void 0 : old.left) != null ? _a : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
              right: [...((_b = old == null ? void 0 : old.right) != null ? _b : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
            };
          }
          if (position === "left") {
            return {
              left: [...((_c = old == null ? void 0 : old.left) != null ? _c : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
              right: ((_d = old == null ? void 0 : old.right) != null ? _d : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
            };
          }
          return {
            left: ((_e = old == null ? void 0 : old.left) != null ? _e : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
            right: ((_f = old == null ? void 0 : old.right) != null ? _f : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
          };
        });
      },
      getCanPin: () => {
        const leafColumns = column.getLeafColumns();
        return leafColumns.some((d) => {
          var _a, _b;
          return ((_a = d.columnDef.enablePinning) != null ? _a : true) && ((_b = table.options.enablePinning) != null ? _b : true);
        });
      },
      getIsPinned: () => {
        const leafColumnIds = column.getLeafColumns().map((d) => d.id);
        const {
          left,
          right
        } = table.getState().columnPinning;
        const isLeft = leafColumnIds.some((d) => left == null ? void 0 : left.includes(d));
        const isRight = leafColumnIds.some((d) => right == null ? void 0 : right.includes(d));
        return isLeft ? "left" : isRight ? "right" : false;
      },
      getPinnedIndex: () => {
        var _a;
        var _table$getState$colum, _table$getState$colum2;
        const position = column.getIsPinned();
        return position ? (_a = (_table$getState$colum = table.getState().columnPinning) == null ? void 0 : (_table$getState$colum2 = _table$getState$colum[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _a : -1 : 0;
      }
    };
  },
  createRow: (row, table) => {
    return {
      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allCells.filter((d) => !leftAndRight.includes(d.column.id));
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
        }
      }),
      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, ,], (allCells, left) => {
        const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
          ...d,
          position: "left"
        }));
        return cells;
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
        }
      }),
      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
        const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
          ...d,
          position: "right"
        }));
        return cells;
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    return {
      setColumnPinning: (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater),
      resetColumnPinning: (defaultState) => {
        var _a;
        var _table$initialState;
        return table.setColumnPinning(defaultState ? getDefaultPinningState() : (_a = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _a : getDefaultPinningState());
      },
      getIsSomeColumnsPinned: (position) => {
        var _pinningState$positio;
        const pinningState = table.getState().columnPinning;
        if (!position) {
          var _pinningState$left, _pinningState$right;
          return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
        }
        return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
      },
      getLeftLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
        return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: "getLeftLeafColumns",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugColumns;
        }
      }),
      getRightLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
        return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: "getRightLeafColumns",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugColumns;
        }
      }),
      getCenterLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allColumns.filter((d) => !leftAndRight.includes(d.id));
      }, {
        key: "getCenterLeafColumns",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugColumns;
        }
      })
    };
  }
};
var RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
    };
  },
  createTable: (table) => {
    return {
      setRowSelection: (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater),
      resetRowSelection: (defaultState) => {
        var _a;
        return table.setRowSelection(defaultState ? {} : (_a = table.initialState.rowSelection) != null ? _a : {});
      },
      toggleAllRowsSelected: (value) => {
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
          const rowSelection = {
            ...old
          };
          const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
          if (value) {
            preGroupedFlatRows.forEach((row) => {
              if (!row.getCanSelect()) {
                return;
              }
              rowSelection[row.id] = true;
            });
          } else {
            preGroupedFlatRows.forEach((row) => {
              delete rowSelection[row.id];
            });
          }
          return rowSelection;
        });
      },
      toggleAllPageRowsSelected: (value) => table.setRowSelection((old) => {
        const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
        const rowSelection = {
          ...old
        };
        table.getRowModel().rows.forEach((row) => {
          mutateRowIsSelected(rowSelection, row.id, resolvedValue, table);
        });
        return rowSelection;
      }),
      getPreSelectedRowModel: () => table.getCoreRowModel(),
      getSelectedRowModel: memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: "getSelectedRowModel",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
        }
      }),
      getFilteredSelectedRowModel: memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
        }
      }),
      getGroupedSelectedRowModel: memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
        }
      }),
      getIsAllRowsSelected: () => {
        const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
        const {
          rowSelection
        } = table.getState();
        let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
        if (isAllRowsSelected) {
          if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
            isAllRowsSelected = false;
          }
        }
        return isAllRowsSelected;
      },
      getIsAllPageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows;
        const {
          rowSelection
        } = table.getState();
        let isAllPageRowsSelected = !!paginationFlatRows.length;
        if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
          isAllPageRowsSelected = false;
        }
        return isAllPageRowsSelected;
      },
      getIsSomeRowsSelected: () => {
        var _a;
        const totalSelected = Object.keys((_a = table.getState().rowSelection) != null ? _a : {}).length;
        return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
      },
      getIsSomePageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows;
        return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.some((d) => d.getIsSelected() || d.getIsSomeSelected());
      },
      getToggleAllRowsSelectedHandler: () => {
        return (e) => {
          table.toggleAllRowsSelected(e.target.checked);
        };
      },
      getToggleAllPageRowsSelectedHandler: () => {
        return (e) => {
          table.toggleAllPageRowsSelected(e.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleSelected: (value) => {
        const isSelected = row.getIsSelected();
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !isSelected;
          if (isSelected === value) {
            return old;
          }
          const selectedRowIds = {
            ...old
          };
          mutateRowIsSelected(selectedRowIds, row.id, value, table);
          return selectedRowIds;
        });
      },
      getIsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isRowSelected(row, rowSelection);
      },
      getIsSomeSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "some";
      },
      getIsAllSubRowsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "all";
      },
      getCanSelect: () => {
        var _a;
        if (typeof table.options.enableRowSelection === "function") {
          return table.options.enableRowSelection(row);
        }
        return (_a = table.options.enableRowSelection) != null ? _a : true;
      },
      getCanSelectSubRows: () => {
        var _a;
        if (typeof table.options.enableSubRowSelection === "function") {
          return table.options.enableSubRowSelection(row);
        }
        return (_a = table.options.enableSubRowSelection) != null ? _a : true;
      },
      getCanMultiSelect: () => {
        var _a;
        if (typeof table.options.enableMultiRowSelection === "function") {
          return table.options.enableMultiRowSelection(row);
        }
        return (_a = table.options.enableMultiRowSelection) != null ? _a : true;
      },
      getToggleSelectedHandler: () => {
        const canSelect = row.getCanSelect();
        return (e) => {
          var _target;
          if (!canSelect)
            return;
          row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, table) => {
  var _row$subRows;
  const row = table.getRow(id);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _a;
  return (_a = selection[row.id]) != null ? _a : false;
}
function isSubRowSelected(row, selection, table) {
  if (row.subRows && row.subRows.length) {
    let allChildrenSelected = true;
    let someSelected = false;
    row.subRows.forEach((subRow) => {
      if (someSelected && !allChildrenSelected) {
        return;
      }
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    });
    return allChildrenSelected ? "all" : someSelected ? "some" : false;
  }
  return false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var Sorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto"
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e) => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoSortingFn: () => {
        const firstRows = table.getFilteredRowModel().flatRows.slice(10);
        let isString = false;
        for (const row of firstRows) {
          const value = row == null ? void 0 : row.getValue(column.id);
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return sortingFns.datetime;
          }
          if (typeof value === "string") {
            isString = true;
            if (value.split(reSplitAlphaNumeric).length > 1) {
              return sortingFns.alphanumeric;
            }
          }
        }
        if (isString) {
          return sortingFns.text;
        }
        return sortingFns.basic;
      },
      getAutoSortDir: () => {
        const firstRow = table.getFilteredRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return "asc";
        }
        return "desc";
      },
      getSortingFn: () => {
        var _a;
        var _table$options$sortin;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_a = (_table$options$sortin = table.options.sortingFns) == null ? void 0 : _table$options$sortin[column.columnDef.sortingFn]) != null ? _a : sortingFns[column.columnDef.sortingFn];
      },
      toggleSorting: (desc, multi) => {
        const nextSortingOrder = column.getNextSortingOrder();
        const hasManualValue = typeof desc !== "undefined" && desc !== null;
        table.setSorting((old) => {
          var _a;
          const existingSorting = old == null ? void 0 : old.find((d) => d.id === column.id);
          const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column.id);
          let newSorting = [];
          let sortAction;
          let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
          if (old != null && old.length && column.getCanMultiSort() && multi) {
            if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "add";
            }
          } else {
            if (old != null && old.length && existingIndex !== old.length - 1) {
              sortAction = "replace";
            } else if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "replace";
            }
          }
          if (sortAction === "toggle") {
            if (!hasManualValue) {
              if (!nextSortingOrder) {
                sortAction = "remove";
              }
            }
          }
          if (sortAction === "add") {
            newSorting = [...old, {
              id: column.id,
              desc: nextDesc
            }];
            newSorting.splice(0, newSorting.length - ((_a = table.options.maxMultiSortColCount) != null ? _a : Number.MAX_SAFE_INTEGER));
          } else if (sortAction === "toggle") {
            newSorting = old.map((d) => {
              if (d.id === column.id) {
                return {
                  ...d,
                  desc: nextDesc
                };
              }
              return d;
            });
          } else if (sortAction === "remove") {
            newSorting = old.filter((d) => d.id !== column.id);
          } else {
            newSorting = [{
              id: column.id,
              desc: nextDesc
            }];
          }
          return newSorting;
        });
      },
      getFirstSortDir: () => {
        var _a, _b;
        const sortDescFirst = (_b = (_a = column.columnDef.sortDescFirst) != null ? _a : table.options.sortDescFirst) != null ? _b : column.getAutoSortDir() === "desc";
        return sortDescFirst ? "desc" : "asc";
      },
      getNextSortingOrder: (multi) => {
        var _a, _b;
        const firstSortDirection = column.getFirstSortDir();
        const isSorted = column.getIsSorted();
        if (!isSorted) {
          return firstSortDirection;
        }
        if (isSorted !== firstSortDirection && ((_a = table.options.enableSortingRemoval) != null ? _a : true) && (multi ? (_b = table.options.enableMultiRemove) != null ? _b : true : true)) {
          return false;
        }
        return isSorted === "desc" ? "asc" : "desc";
      },
      getCanSort: () => {
        var _a, _b;
        return ((_a = column.columnDef.enableSorting) != null ? _a : true) && ((_b = table.options.enableSorting) != null ? _b : true) && !!column.accessorFn;
      },
      getCanMultiSort: () => {
        var _a, _b;
        return (_b = (_a = column.columnDef.enableMultiSort) != null ? _a : table.options.enableMultiSort) != null ? _b : !!column.accessorFn;
      },
      getIsSorted: () => {
        var _table$getState$sorti;
        const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column.id);
        return !columnSort ? false : columnSort.desc ? "desc" : "asc";
      },
      getSortIndex: () => {
        var _a;
        var _table$getState$sorti2;
        return (_a = (_table$getState$sorti2 = table.getState().sorting) == null ? void 0 : _table$getState$sorti2.findIndex((d) => d.id === column.id)) != null ? _a : -1;
      },
      clearSorting: () => {
        table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column.id) : []);
      },
      getToggleSortingHandler: () => {
        const canSort = column.getCanSort();
        return (e) => {
          if (!canSort)
            return;
          e.persist == null ? void 0 : e.persist();
          column.toggleSorting == null ? void 0 : column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setSorting: (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater),
      resetSorting: (defaultState) => {
        var _a;
        var _table$initialState;
        table.setSorting(defaultState ? [] : (_a = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _a : []);
      },
      getPreSortedRowModel: () => table.getGroupedRowModel(),
      getSortedRowModel: () => {
        if (!table._getSortedRowModel && table.options.getSortedRowModel) {
          table._getSortedRowModel = table.options.getSortedRowModel(table);
        }
        if (table.options.manualSorting || !table._getSortedRowModel) {
          return table.getPreSortedRowModel();
        }
        return table._getSortedRowModel();
      }
    };
  }
};
var Visibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    return {
      toggleVisibility: (value) => {
        if (column.getCanHide()) {
          table.setColumnVisibility((old) => ({
            ...old,
            [column.id]: value != null ? value : !column.getIsVisible()
          }));
        }
      },
      getIsVisible: () => {
        var _a;
        var _table$getState$colum;
        return (_a = (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _a : true;
      },
      getCanHide: () => {
        var _a, _b;
        return ((_a = column.columnDef.enableHiding) != null ? _a : true) && ((_b = table.options.enableHiding) != null ? _b : true);
      },
      getToggleVisibilityHandler: () => {
        return (e) => {
          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      _getAllVisibleCells: memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
        return cells.filter((cell) => cell.column.getIsVisible());
      }, {
        key: false,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
        }
      }),
      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {
        key: "row.getVisibleCells",
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
        return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, {
        key,
        debug: () => {
          var _a;
          return (_a = table.options.debugAll) != null ? _a : table.options.debugColumns;
        }
      });
    };
    return {
      getVisibleFlatColumns: makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns()),
      getVisibleLeafColumns: makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns()),
      getLeftVisibleLeafColumns: makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns()),
      getRightVisibleLeafColumns: makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns()),
      getCenterVisibleLeafColumns: makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns()),
      setColumnVisibility: (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater),
      resetColumnVisibility: (defaultState) => {
        var _a;
        table.setColumnVisibility(defaultState ? {} : (_a = table.initialState.columnVisibility) != null ? _a : {});
      },
      toggleAllColumnsVisible: (value) => {
        value = value != null ? value : !table.getIsAllColumnsVisible();
        table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
          ...obj,
          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
        }), {}));
      },
      getIsAllColumnsVisible: () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible())),
      getIsSomeColumnsVisible: () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible()),
      getToggleAllColumnsVisibilityHandler: () => {
        return (e) => {
          var _target;
          table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
var features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];
function createTable(options) {
  var _a;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  let table = {
    _features: features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_a = options.initialState) != null ? _a : {}
  };
  table._features.forEach((feature) => {
    var _a2;
    initialState = (_a2 = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _a2 : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features: features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null ? void 0 : table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _a2;
      return (_a2 = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _a2 : `${parent ? [parent.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    getRow: (id) => {
      const row = table.getRowModel().rowsById[id];
      if (!row) {
        if (true) {
          throw new Error(`getRow expected an ID, but got ${id}`);
        }
        throw new Error();
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      defaultColumn = defaultColumn != null ? defaultColumn : {};
      return {
        header: (props2) => {
          const resolvedColumnDef = props2.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        cell: (props2) => {
          var _a2;
          var _props$renderValue;
          return (_a2 = (_props$renderValue = props2.renderValue()) == null ? void 0 : _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _a2 : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, {
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      },
      key: "getDefaultColumnDef"
    }),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, {
      key: "getAllColumns",
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    }),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, {
      key: "getAllFlatColumns",
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    }),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, {
      key: "getAllFlatColumnsById",
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    }),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, {
      key: "getAllLeafColumns",
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
      }
    }),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        if (true) {
          console.warn(`[Table] Column with id ${columnId} does not exist.`);
        }
        throw new Error();
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  table._features.forEach((feature) => {
    return Object.assign(table, feature.createTable == null ? void 0 : feature.createTable(table));
  });
  return table;
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _a;
    return (_a = cell.getValue()) != null ? _a : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), {
      key: "cell.getContext",
      debug: () => table.options.debugAll
    })
  };
  table._features.forEach((feature) => {
    Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, table));
  }, {});
  return cell;
}
var createRow = (table, id, original, rowIndex, depth, subRows) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!column.accessorFn) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!column.accessorFn) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _a;
      return (_a = row.getValue(columnId)) != null ? _a : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, {
      key: "row.getAllCells",
      debug: () => {
        var _a;
        return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
      }
    }),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, {
      key: false,
      debug: () => {
        var _a;
        return (_a = table.options.debugAll) != null ? _a : table.options.debugRows;
      }
    })
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, table));
  }
  return row;
};
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parent) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        const row = createRow(table, table._getRowId(originalRows[i], i, parent), originalRows[i], i, depth);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, {
    key: "getRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const recurseFilterRows = function(rowsToFilter2, depth) {
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      var _row$subRows;
      let row = rowsToFilter2[i];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
        newRow.subRows = recurseFilterRows(row.subRows);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const recurseFilterRows = function(rowsToFilter2, depth) {
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      let row = rowsToFilter2[i];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth);
          newRow.subRows = recurseFilterRows(row.subRows);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i = 0; i < rowModel.flatRows.length; i++) {
        rowModel.flatRows[i].columnFilters = {};
        rowModel.flatRows[i].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d) => {
      var _a;
      const column = table.getColumn(d.id);
      if (!column) {
        if (true) {
          console.warn(`Table: Could not find a column to filter with columnId: ${d.id}`);
        }
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (true) {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d.id,
        filterFn,
        resolvedValue: (_a = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _a : d.value
      });
    });
    const filterableIds = columnFilters.map((d) => d.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _a;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_a = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _a : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i = 0; i < resolvedColumnFilters.length; i++) {
          currentColumnFilter = resolvedColumnFilters[i];
          const id = currentColumnFilter.id;
          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i = 0; i < resolvedGlobalFilters.length; i++) {
          currentGlobalFilter = resolvedGlobalFilters[i];
          const id = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, {
    key: "getFilteredRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getFacetedRowModel() {
  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {
    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      return preRowModel;
    }
    const filterableIds = [...columnFilters.map((d) => d.id).filter((d) => d !== columnId), globalFilter ? "__global__" : void 0].filter(Boolean);
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(preRowModel.rows, filterRowsImpl, table);
  }, {
    key: "getFacetedRowModel_" + columnId,
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    },
    onChange: () => {
    }
  });
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => table.getColumn(sort.id).getCanSort());
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = [...rows];
      sortedData.sort((rowA, rowB) => {
        var _a;
        for (let i = 0; i < availableSorting.length; i += 1) {
          const sortEntry = availableSorting[i];
          const columnInfo = columnInfoById[sortEntry.id];
          const isDesc = (_a = sortEntry == null ? void 0 : sortEntry.desc) != null ? _a : false;
          if (columnInfo.sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = typeof aValue === "undefined";
            const bUndefined = typeof bValue === "undefined";
            if (aUndefined || bUndefined) {
              return aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;
            }
          }
          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, {
    key: "getSortedRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getGroupedRowModel() {
  return (table) => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      return rowModel;
    }
    const existingGrouping = grouping.filter((columnId) => table.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {};
    const groupUpRecursively = function(rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }
      if (depth >= existingGrouping.length) {
        return rows.map((row) => {
          row.depth = depth;
          groupedFlatRows.push(row);
          groupedRowsById[row.id] = row;
          if (row.subRows) {
            row.subRows = groupUpRecursively(row.subRows, depth + 1);
          }
          return row;
        });
      }
      const columnId = existingGrouping[depth];
      const rowGroupsMap = groupBy(rows, columnId);
      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows2] = _ref;
        let id = `${columnId}:${groupingValue}`;
        id = parentId ? `${parentId}>${id}` : id;
        const subRows = groupUpRecursively(groupedRows2, depth + 1, id);
        const leafRows = depth ? flattenBy(groupedRows2, (row2) => row2.subRows) : groupedRows2;
        const row = createRow(table, id, leafRows[0].original, index, depth);
        Object.assign(row, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: (columnId2) => {
            var _a;
            if (existingGrouping.includes(columnId2)) {
              if (row._valuesCache.hasOwnProperty(columnId2)) {
                return row._valuesCache[columnId2];
              }
              if (groupedRows2[0]) {
                row._valuesCache[columnId2] = (_a = groupedRows2[0].getValue(columnId2)) != null ? _a : void 0;
              }
              return row._valuesCache[columnId2];
            }
            if (row._groupingValuesCache.hasOwnProperty(columnId2)) {
              return row._groupingValuesCache[columnId2];
            }
            const column = table.getColumn(columnId2);
            const aggregateFn = column.getAggregationFn();
            if (aggregateFn) {
              row._groupingValuesCache[columnId2] = aggregateFn(columnId2, leafRows, groupedRows2);
              return row._groupingValuesCache[columnId2];
            }
          }
        });
        subRows.forEach((subRow) => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow;
        });
        return row;
      });
      return aggregatedGroupedRows;
    };
    const groupedRows = groupUpRecursively(rowModel.rows, 0, "");
    groupedRows.forEach((subRow) => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow;
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, {
    key: "getGroupedRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    },
    onChange: () => {
      table._queue(() => {
        table._autoResetExpanded();
        table._autoResetPageIndex();
      });
    }
  });
}
function groupBy(rows, columnId) {
  const groupMap = /* @__PURE__ */ new Map();
  return rows.reduce((map, row) => {
    const resKey = `${row.getValue(columnId)}`;
    const previous = map.get(resKey);
    if (!previous) {
      map.set(resKey, [row]);
    } else {
      previous.push(row);
    }
    return map;
  }, groupMap);
}
function getExpandedRowModel() {
  return (table) => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      return rowModel;
    }
    return expandRows(rowModel);
  }, {
    key: "getExpandedRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    }
  });
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}
function getPaginationRowModel(opts) {
  return (table) => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? void 0 : table.getState().expanded], (pagination, rowModel) => {
    if (!rowModel.rows.length) {
      return rowModel;
    }
    const {
      pageSize,
      pageIndex
    } = pagination;
    let {
      rows,
      flatRows,
      rowsById
    } = rowModel;
    const pageStart = pageSize * pageIndex;
    const pageEnd = pageStart + pageSize;
    rows = rows.slice(pageStart, pageEnd);
    let paginatedRowModel;
    if (!table.options.paginateExpandedRows) {
      paginatedRowModel = expandRows({
        rows,
        flatRows,
        rowsById
      });
    } else {
      paginatedRowModel = {
        rows,
        flatRows,
        rowsById
      };
    }
    paginatedRowModel.flatRows = [];
    const handleRow = (row) => {
      paginatedRowModel.flatRows.push(row);
      if (row.subRows.length) {
        row.subRows.forEach(handleRow);
      }
    };
    paginatedRowModel.rows.forEach(handleRow);
    return paginatedRowModel;
  }, {
    key: "getPaginationRowModel",
    debug: () => {
      var _a;
      return (_a = table.options.debugAll) != null ? _a : table.options.debugTable;
    }
  });
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    onStateChange: () => {
    },
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null ? void 0 : options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// node_modules/@tanstack/match-sorter-utils/build/esm/index.js
var characterMap = {
  \u00C0: "A",
  \u00C1: "A",
  \u00C2: "A",
  \u00C3: "A",
  \u00C4: "A",
  \u00C5: "A",
  \u1EA4: "A",
  \u1EAE: "A",
  \u1EB2: "A",
  \u1EB4: "A",
  \u1EB6: "A",
  \u00C6: "AE",
  \u1EA6: "A",
  \u1EB0: "A",
  \u0202: "A",
  \u00C7: "C",
  \u1E08: "C",
  \u00C8: "E",
  \u00C9: "E",
  \u00CA: "E",
  \u00CB: "E",
  \u1EBE: "E",
  \u1E16: "E",
  \u1EC0: "E",
  \u1E14: "E",
  \u1E1C: "E",
  \u0206: "E",
  \u00CC: "I",
  \u00CD: "I",
  \u00CE: "I",
  \u00CF: "I",
  \u1E2E: "I",
  \u020A: "I",
  \u00D0: "D",
  \u00D1: "N",
  \u00D2: "O",
  \u00D3: "O",
  \u00D4: "O",
  \u00D5: "O",
  \u00D6: "O",
  \u00D8: "O",
  \u1ED0: "O",
  \u1E4C: "O",
  \u1E52: "O",
  \u020E: "O",
  \u00D9: "U",
  \u00DA: "U",
  \u00DB: "U",
  \u00DC: "U",
  \u00DD: "Y",
  \u00E0: "a",
  \u00E1: "a",
  \u00E2: "a",
  \u00E3: "a",
  \u00E4: "a",
  \u00E5: "a",
  \u1EA5: "a",
  \u1EAF: "a",
  \u1EB3: "a",
  \u1EB5: "a",
  \u1EB7: "a",
  \u00E6: "ae",
  \u1EA7: "a",
  \u1EB1: "a",
  \u0203: "a",
  \u00E7: "c",
  \u1E09: "c",
  \u00E8: "e",
  \u00E9: "e",
  \u00EA: "e",
  \u00EB: "e",
  \u1EBF: "e",
  \u1E17: "e",
  \u1EC1: "e",
  \u1E15: "e",
  \u1E1D: "e",
  \u0207: "e",
  \u00EC: "i",
  \u00ED: "i",
  \u00EE: "i",
  \u00EF: "i",
  \u1E2F: "i",
  \u020B: "i",
  \u00F0: "d",
  \u00F1: "n",
  \u00F2: "o",
  \u00F3: "o",
  \u00F4: "o",
  \u00F5: "o",
  \u00F6: "o",
  \u00F8: "o",
  \u1ED1: "o",
  \u1E4D: "o",
  \u1E53: "o",
  \u020F: "o",
  \u00F9: "u",
  \u00FA: "u",
  \u00FB: "u",
  \u00FC: "u",
  \u00FD: "y",
  \u00FF: "y",
  \u0100: "A",
  \u0101: "a",
  \u0102: "A",
  \u0103: "a",
  \u0104: "A",
  \u0105: "a",
  \u0106: "C",
  \u0107: "c",
  \u0108: "C",
  \u0109: "c",
  \u010A: "C",
  \u010B: "c",
  \u010C: "C",
  \u010D: "c",
  C\u0306: "C",
  c\u0306: "c",
  \u010E: "D",
  \u010F: "d",
  \u0110: "D",
  \u0111: "d",
  \u0112: "E",
  \u0113: "e",
  \u0114: "E",
  \u0115: "e",
  \u0116: "E",
  \u0117: "e",
  \u0118: "E",
  \u0119: "e",
  \u011A: "E",
  \u011B: "e",
  \u011C: "G",
  \u01F4: "G",
  \u011D: "g",
  \u01F5: "g",
  \u011E: "G",
  \u011F: "g",
  \u0120: "G",
  \u0121: "g",
  \u0122: "G",
  \u0123: "g",
  \u0124: "H",
  \u0125: "h",
  \u0126: "H",
  \u0127: "h",
  \u1E2A: "H",
  \u1E2B: "h",
  \u0128: "I",
  \u0129: "i",
  \u012A: "I",
  \u012B: "i",
  \u012C: "I",
  \u012D: "i",
  \u012E: "I",
  \u012F: "i",
  \u0130: "I",
  \u0131: "i",
  \u0132: "IJ",
  \u0133: "ij",
  \u0134: "J",
  \u0135: "j",
  \u0136: "K",
  \u0137: "k",
  \u1E30: "K",
  \u1E31: "k",
  K\u0306: "K",
  k\u0306: "k",
  \u0139: "L",
  \u013A: "l",
  \u013B: "L",
  \u013C: "l",
  \u013D: "L",
  \u013E: "l",
  \u013F: "L",
  \u0140: "l",
  \u0141: "l",
  \u0142: "l",
  \u1E3E: "M",
  \u1E3F: "m",
  M\u0306: "M",
  m\u0306: "m",
  \u0143: "N",
  \u0144: "n",
  \u0145: "N",
  \u0146: "n",
  \u0147: "N",
  \u0148: "n",
  \u0149: "n",
  N\u0306: "N",
  n\u0306: "n",
  \u014C: "O",
  \u014D: "o",
  \u014E: "O",
  \u014F: "o",
  \u0150: "O",
  \u0151: "o",
  \u0152: "OE",
  \u0153: "oe",
  P\u0306: "P",
  p\u0306: "p",
  \u0154: "R",
  \u0155: "r",
  \u0156: "R",
  \u0157: "r",
  \u0158: "R",
  \u0159: "r",
  R\u0306: "R",
  r\u0306: "r",
  \u0212: "R",
  \u0213: "r",
  \u015A: "S",
  \u015B: "s",
  \u015C: "S",
  \u015D: "s",
  \u015E: "S",
  \u0218: "S",
  \u0219: "s",
  \u015F: "s",
  \u0160: "S",
  \u0161: "s",
  \u0162: "T",
  \u0163: "t",
  \u021B: "t",
  \u021A: "T",
  \u0164: "T",
  \u0165: "t",
  \u0166: "T",
  \u0167: "t",
  T\u0306: "T",
  t\u0306: "t",
  \u0168: "U",
  \u0169: "u",
  \u016A: "U",
  \u016B: "u",
  \u016C: "U",
  \u016D: "u",
  \u016E: "U",
  \u016F: "u",
  \u0170: "U",
  \u0171: "u",
  \u0172: "U",
  \u0173: "u",
  \u0216: "U",
  \u0217: "u",
  V\u0306: "V",
  v\u0306: "v",
  \u0174: "W",
  \u0175: "w",
  \u1E82: "W",
  \u1E83: "w",
  X\u0306: "X",
  x\u0306: "x",
  \u0176: "Y",
  \u0177: "y",
  \u0178: "Y",
  Y\u0306: "Y",
  y\u0306: "y",
  \u0179: "Z",
  \u017A: "z",
  \u017B: "Z",
  \u017C: "z",
  \u017D: "Z",
  \u017E: "z",
  \u017F: "s",
  \u0192: "f",
  \u01A0: "O",
  \u01A1: "o",
  \u01AF: "U",
  \u01B0: "u",
  \u01CD: "A",
  \u01CE: "a",
  \u01CF: "I",
  \u01D0: "i",
  \u01D1: "O",
  \u01D2: "o",
  \u01D3: "U",
  \u01D4: "u",
  \u01D5: "U",
  \u01D6: "u",
  \u01D7: "U",
  \u01D8: "u",
  \u01D9: "U",
  \u01DA: "u",
  \u01DB: "U",
  \u01DC: "u",
  \u1EE8: "U",
  \u1EE9: "u",
  \u1E78: "U",
  \u1E79: "u",
  \u01FA: "A",
  \u01FB: "a",
  \u01FC: "AE",
  \u01FD: "ae",
  \u01FE: "O",
  \u01FF: "o",
  \u00DE: "TH",
  \u00FE: "th",
  \u1E54: "P",
  \u1E55: "p",
  \u1E64: "S",
  \u1E65: "s",
  X\u0301: "X",
  x\u0301: "x",
  \u0403: "\u0413",
  \u0453: "\u0433",
  \u040C: "\u041A",
  \u045C: "\u043A",
  A\u030B: "A",
  a\u030B: "a",
  E\u030B: "E",
  e\u030B: "e",
  I\u030B: "I",
  i\u030B: "i",
  \u01F8: "N",
  \u01F9: "n",
  \u1ED2: "O",
  \u1ED3: "o",
  \u1E50: "O",
  \u1E51: "o",
  \u1EEA: "U",
  \u1EEB: "u",
  \u1E80: "W",
  \u1E81: "w",
  \u1EF2: "Y",
  \u1EF3: "y",
  \u0200: "A",
  \u0201: "a",
  \u0204: "E",
  \u0205: "e",
  \u0208: "I",
  \u0209: "i",
  \u020C: "O",
  \u020D: "o",
  \u0210: "R",
  \u0211: "r",
  \u0214: "U",
  \u0215: "u",
  B\u030C: "B",
  b\u030C: "b",
  \u010C\u0323: "C",
  \u010D\u0323: "c",
  \u00CA\u030C: "E",
  \u00EA\u030C: "e",
  F\u030C: "F",
  f\u030C: "f",
  \u01E6: "G",
  \u01E7: "g",
  \u021E: "H",
  \u021F: "h",
  J\u030C: "J",
  \u01F0: "j",
  \u01E8: "K",
  \u01E9: "k",
  M\u030C: "M",
  m\u030C: "m",
  P\u030C: "P",
  p\u030C: "p",
  Q\u030C: "Q",
  q\u030C: "q",
  \u0158\u0329: "R",
  \u0159\u0329: "r",
  \u1E66: "S",
  \u1E67: "s",
  V\u030C: "V",
  v\u030C: "v",
  W\u030C: "W",
  w\u030C: "w",
  X\u030C: "X",
  x\u030C: "x",
  Y\u030C: "Y",
  y\u030C: "y",
  A\u0327: "A",
  a\u0327: "a",
  B\u0327: "B",
  b\u0327: "b",
  \u1E10: "D",
  \u1E11: "d",
  \u0228: "E",
  \u0229: "e",
  \u0190\u0327: "E",
  \u025B\u0327: "e",
  \u1E28: "H",
  \u1E29: "h",
  I\u0327: "I",
  i\u0327: "i",
  \u0197\u0327: "I",
  \u0268\u0327: "i",
  M\u0327: "M",
  m\u0327: "m",
  O\u0327: "O",
  o\u0327: "o",
  Q\u0327: "Q",
  q\u0327: "q",
  U\u0327: "U",
  u\u0327: "u",
  X\u0327: "X",
  x\u0327: "x",
  Z\u0327: "Z",
  z\u0327: "z"
};
var chars = Object.keys(characterMap).join("|");
var allAccents = new RegExp(chars, "g");
function removeAccents(str) {
  return str.replace(allAccents, (match) => {
    return characterMap[match];
  });
}
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
function rankItem(item, value, options) {
  var _a;
  options = options || {};
  options.threshold = (_a = options.threshold) != null ? _a : rankings.MATCHES;
  if (!options.accessors) {
    const rank = getMatchRanking(item, value, options);
    return {
      rankedValue: item,
      rank,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: rank >= options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item, options.accessors);
  const rankingInfo = {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    accessorIndex: -1,
    accessorThreshold: options.threshold,
    passed: false
  };
  for (let i = 0; i < valuesToRank.length; i++) {
    const rankValue = valuesToRank[i];
    let newRank = getMatchRanking(rankValue.itemValue, value, options);
    const {
      minRanking,
      maxRanking,
      threshold = options.threshold
    } = rankValue.attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    newRank = Math.min(newRank, maxRanking);
    if (newRank >= threshold && newRank > rankingInfo.rank) {
      rankingInfo.rank = newRank;
      rankingInfo.passed = true;
      rankingInfo.accessorIndex = i;
      rankingInfo.accessorThreshold = threshold;
      rankingInfo.rankedValue = rankValue.itemValue;
    }
  }
  return rankingInfo;
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  let acronym = "";
  const wordsInString = string.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string, index) {
    for (let j = index, J = string.length; j < J; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i = 1, I = stringToRank.length; i < I; i++) {
    const matchChar = stringToRank[i];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function compareItems(a, b) {
  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;
}
function prepareValueForComparison(value, _ref) {
  let {
    keepDiacritics
  } = _ref;
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}
function getItemValues(item, accessor) {
  let accessorFn = accessor;
  if (typeof accessor === "object") {
    accessorFn = accessor.accessor;
  }
  const value = accessorFn(item);
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getAllValuesToRank(item, accessors) {
  const allValues = [];
  for (let j = 0, J = accessors.length; j < J; j++) {
    const accessor = accessors[j];
    const attributes = getAccessorAttributes(accessor);
    const itemValues = getItemValues(item, accessor);
    for (let i = 0, I = itemValues.length; i < I; i++) {
      allValues.push({
        itemValue: itemValues[i],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getAccessorAttributes(accessor) {
  if (typeof accessor === "function") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...accessor
  };
}

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
var import_ArrowDownward = __toESM(require_ArrowDownward());
var import_ArrowRight = __toESM(require_ArrowRight());
var import_Cancel = __toESM(require_Cancel());
var import_CheckBox = __toESM(require_CheckBox());
var import_ClearAll = __toESM(require_ClearAll());
var import_Close = __toESM(require_Close());
var import_DensityLarge = __toESM(require_DensityLarge());
var import_DensityMedium = __toESM(require_DensityMedium());
var import_DensitySmall = __toESM(require_DensitySmall());
var import_DragHandle = __toESM(require_DragHandle());
var import_DynamicFeed = __toESM(require_DynamicFeed());
var import_Edit = __toESM(require_Edit());
var import_ExpandLess = __toESM(require_ExpandLess());
var import_ExpandMore = __toESM(require_ExpandMore());
var import_FilterAlt = __toESM(require_FilterAlt());
var import_FilterAltOff = __toESM(require_FilterAltOff());
var import_FilterList = __toESM(require_FilterList());
var import_FilterListOff = __toESM(require_FilterListOff());
var import_FullscreenExit = __toESM(require_FullscreenExit());
var import_Fullscreen = __toESM(require_Fullscreen());
var import_KeyboardDoubleArrowDown = __toESM(require_KeyboardDoubleArrowDown());
var import_MoreHoriz = __toESM(require_MoreHoriz());
var import_MoreVert = __toESM(require_MoreVert());
var import_PushPin = __toESM(require_PushPin());
var import_RestartAlt = __toESM(require_RestartAlt());
var import_Save = __toESM(require_Save());
var import_Search = __toESM(require_Search());
var import_SearchOff = __toESM(require_SearchOff());
var import_Sort = __toESM(require_Sort());
var import_ViewColumn = __toESM(require_ViewColumn());
var import_VisibilityOff = __toESM(require_VisibilityOff());
var import_debounce = __toESM(require_debounce());

// node_modules/material-react-table/node_modules/react-virtual/dist/react-virtual.mjs
var import_react = __toESM(require_react(), 1);
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var props = ["bottom", "height", "left", "right", "top", "width"];
var rectChanged = function rectChanged2(a, b) {
  if (a === void 0) {
    a = {};
  }
  if (b === void 0) {
    b = {};
  }
  return props.some(function(prop) {
    return a[prop] !== b[prop];
  });
};
var observedNodes = /* @__PURE__ */ new Map();
var rafId;
var run = function run2() {
  var changedStates = [];
  observedNodes.forEach(function(state, node) {
    var newRect = node.getBoundingClientRect();
    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function(state) {
    state.callbacks.forEach(function(cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run2);
};
function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;
      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: void 0,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }
      if (wasEmpty)
        run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);
      if (state) {
        var index = state.callbacks.indexOf(cb);
        if (index >= 0)
          state.callbacks.splice(index, 1);
        if (!state.callbacks.length)
          observedNodes["delete"](node);
        if (!observedNodes.size)
          cancelAnimationFrame(rafId);
      }
    }
  };
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function useRect(nodeRef, initialRect) {
  if (initialRect === void 0) {
    initialRect = {
      width: 0,
      height: 0
    };
  }
  var _React$useState = import_react.default.useState(nodeRef.current), element = _React$useState[0], setElement = _React$useState[1];
  var _React$useReducer = import_react.default.useReducer(rectReducer, initialRect), rect = _React$useReducer[0], dispatch = _React$useReducer[1];
  var initialRectSet = import_react.default.useRef(false);
  useIsomorphicLayoutEffect(function() {
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (element && !initialRectSet.current) {
      initialRectSet.current = true;
      var _rect = element.getBoundingClientRect();
      dispatch({
        rect: _rect
      });
    }
  }, [element]);
  import_react.default.useEffect(function() {
    if (!element) {
      return;
    }
    var observer = observeRect(element, function(rect2) {
      dispatch({
        rect: rect2
      });
    });
    observer.observe();
    return function() {
      observer.unobserve();
    };
  }, [element]);
  return rect;
}
function rectReducer(state, action) {
  var rect = action.rect;
  if (state.height !== rect.height || state.width !== rect.width) {
    return rect;
  }
  return state;
}
var defaultEstimateSize = function defaultEstimateSize2() {
  return 50;
};
var defaultKeyExtractor = function defaultKeyExtractor2(index) {
  return index;
};
var defaultMeasureSize = function defaultMeasureSize2(el, horizontal) {
  var key = horizontal ? "offsetWidth" : "offsetHeight";
  return el[key];
};
var defaultRangeExtractor = function defaultRangeExtractor2(range) {
  var start = Math.max(range.start - range.overscan, 0);
  var end = Math.min(range.end + range.overscan, range.size - 1);
  var arr = [];
  for (var i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
function useVirtual(_ref) {
  var _measurements;
  var _ref$size = _ref.size, size = _ref$size === void 0 ? 0 : _ref$size, _ref$estimateSize = _ref.estimateSize, estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize, _ref$overscan = _ref.overscan, overscan = _ref$overscan === void 0 ? 1 : _ref$overscan, _ref$paddingStart = _ref.paddingStart, paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart, _ref$paddingEnd = _ref.paddingEnd, paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd, parentRef = _ref.parentRef, horizontal = _ref.horizontal, scrollToFn = _ref.scrollToFn, useObserver = _ref.useObserver, initialRect = _ref.initialRect, onScrollElement = _ref.onScrollElement, scrollOffsetFn = _ref.scrollOffsetFn, _ref$keyExtractor = _ref.keyExtractor, keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor, _ref$measureSize = _ref.measureSize, measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize, _ref$rangeExtractor = _ref.rangeExtractor, rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;
  var sizeKey = horizontal ? "width" : "height";
  var scrollKey = horizontal ? "scrollLeft" : "scrollTop";
  var latestRef = import_react.default.useRef({
    scrollOffset: 0,
    measurements: []
  });
  var _React$useState = import_react.default.useState(0), scrollOffset = _React$useState[0], setScrollOffset = _React$useState[1];
  latestRef.current.scrollOffset = scrollOffset;
  var useMeasureParent = useObserver || useRect;
  var _useMeasureParent = useMeasureParent(parentRef, initialRect), outerSize = _useMeasureParent[sizeKey];
  latestRef.current.outerSize = outerSize;
  var defaultScrollToFn = import_react.default.useCallback(function(offset) {
    if (parentRef.current) {
      parentRef.current[scrollKey] = offset;
    }
  }, [parentRef, scrollKey]);
  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;
  scrollToFn = import_react.default.useCallback(function(offset) {
    resolvedScrollToFn(offset, defaultScrollToFn);
  }, [defaultScrollToFn, resolvedScrollToFn]);
  var _React$useState2 = import_react.default.useState({}), measuredCache = _React$useState2[0], setMeasuredCache = _React$useState2[1];
  var measure = import_react.default.useCallback(function() {
    return setMeasuredCache({});
  }, []);
  var pendingMeasuredCacheIndexesRef = import_react.default.useRef([]);
  var measurements = import_react.default.useMemo(function() {
    var min2 = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;
    pendingMeasuredCacheIndexesRef.current = [];
    var measurements2 = latestRef.current.measurements.slice(0, min2);
    for (var i = min2; i < size; i++) {
      var key = keyExtractor(i);
      var measuredSize = measuredCache[key];
      var _start = measurements2[i - 1] ? measurements2[i - 1].end : paddingStart;
      var _size = typeof measuredSize === "number" ? measuredSize : estimateSize(i);
      var _end = _start + _size;
      measurements2[i] = {
        index: i,
        start: _start,
        size: _size,
        end: _end,
        key
      };
    }
    return measurements2;
  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);
  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;
  latestRef.current.measurements = measurements;
  latestRef.current.totalSize = totalSize;
  var element = onScrollElement ? onScrollElement.current : parentRef.current;
  var scrollOffsetFnRef = import_react.default.useRef(scrollOffsetFn);
  scrollOffsetFnRef.current = scrollOffsetFn;
  useIsomorphicLayoutEffect(function() {
    if (!element) {
      setScrollOffset(0);
      return;
    }
    var onScroll = function onScroll2(event) {
      var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];
      setScrollOffset(offset);
    };
    onScroll();
    element.addEventListener("scroll", onScroll, {
      capture: false,
      passive: true
    });
    return function() {
      element.removeEventListener("scroll", onScroll);
    };
  }, [element, scrollKey]);
  var _calculateRange = calculateRange(latestRef.current), start = _calculateRange.start, end = _calculateRange.end;
  var indexes = import_react.default.useMemo(function() {
    return rangeExtractor({
      start,
      end,
      overscan,
      size: measurements.length
    });
  }, [start, end, overscan, measurements.length, rangeExtractor]);
  var measureSizeRef = import_react.default.useRef(measureSize);
  measureSizeRef.current = measureSize;
  var virtualItems = import_react.default.useMemo(function() {
    var virtualItems2 = [];
    var _loop = function _loop2(k2, len2) {
      var i = indexes[k2];
      var measurement = measurements[i];
      var item = _extends(_extends({}, measurement), {}, {
        measureRef: function measureRef(el) {
          if (el) {
            var measuredSize = measureSizeRef.current(el, horizontal);
            if (measuredSize !== item.size) {
              var _scrollOffset = latestRef.current.scrollOffset;
              if (item.start < _scrollOffset) {
                defaultScrollToFn(_scrollOffset + (measuredSize - item.size));
              }
              pendingMeasuredCacheIndexesRef.current.push(i);
              setMeasuredCache(function(old) {
                var _extends2;
                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));
              });
            }
          }
        }
      });
      virtualItems2.push(item);
    };
    for (var k = 0, len = indexes.length; k < len; k++) {
      _loop(k);
    }
    return virtualItems2;
  }, [indexes, defaultScrollToFn, horizontal, measurements]);
  var mountedRef = import_react.default.useRef(false);
  useIsomorphicLayoutEffect(function() {
    if (mountedRef.current) {
      setMeasuredCache({});
    }
    mountedRef.current = true;
  }, [estimateSize]);
  var scrollToOffset = import_react.default.useCallback(function(toOffset, _temp) {
    var _ref2 = _temp === void 0 ? {} : _temp, _ref2$align = _ref2.align, align = _ref2$align === void 0 ? "start" : _ref2$align;
    var _latestRef$current = latestRef.current, scrollOffset2 = _latestRef$current.scrollOffset, outerSize2 = _latestRef$current.outerSize;
    if (align === "auto") {
      if (toOffset <= scrollOffset2) {
        align = "start";
      } else if (toOffset >= scrollOffset2 + outerSize2) {
        align = "end";
      } else {
        align = "start";
      }
    }
    if (align === "start") {
      scrollToFn(toOffset);
    } else if (align === "end") {
      scrollToFn(toOffset - outerSize2);
    } else if (align === "center") {
      scrollToFn(toOffset - outerSize2 / 2);
    }
  }, [scrollToFn]);
  var tryScrollToIndex = import_react.default.useCallback(function(index, _temp2) {
    var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$align = _ref3.align, align = _ref3$align === void 0 ? "auto" : _ref3$align, rest = _objectWithoutPropertiesLoose(_ref3, ["align"]);
    var _latestRef$current2 = latestRef.current, measurements2 = _latestRef$current2.measurements, scrollOffset2 = _latestRef$current2.scrollOffset, outerSize2 = _latestRef$current2.outerSize;
    var measurement = measurements2[Math.max(0, Math.min(index, size - 1))];
    if (!measurement) {
      return;
    }
    if (align === "auto") {
      if (measurement.end >= scrollOffset2 + outerSize2) {
        align = "end";
      } else if (measurement.start <= scrollOffset2) {
        align = "start";
      } else {
        return;
      }
    }
    var toOffset = align === "center" ? measurement.start + measurement.size / 2 : align === "end" ? measurement.end : measurement.start;
    scrollToOffset(toOffset, _extends({
      align
    }, rest));
  }, [scrollToOffset, size]);
  var scrollToIndex = import_react.default.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    tryScrollToIndex.apply(void 0, args);
    requestAnimationFrame(function() {
      tryScrollToIndex.apply(void 0, args);
    });
  }, [tryScrollToIndex]);
  return {
    virtualItems,
    totalSize,
    scrollToOffset,
    scrollToIndex,
    measure
  };
}
var findNearestBinarySearch = function findNearestBinarySearch2(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref4) {
  var measurements = _ref4.measurements, outerSize = _ref4.outerSize, scrollOffset = _ref4.scrollOffset;
  var size = measurements.length - 1;
  var getOffset = function getOffset2(index) {
    return measurements[index].start;
  };
  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);
  var end = start;
  while (end < size && measurements[end].end < scrollOffset + outerSize) {
    end++;
  }
  return {
    start,
    end
  };
}

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var MRT_AggregationFns = Object.assign({}, aggregationFns);
var getColumnId = (columnDef) => {
  var _a, _b, _c, _d;
  return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header;
};
var getAllLeafColumnDefs = (columns) => {
  const allLeafColumnDefs = [];
  const getLeafColumns = (cols) => {
    cols.forEach((col) => {
      if (col.columns) {
        getLeafColumns(col.columns);
      } else {
        allLeafColumnDefs.push(col);
      }
    });
  };
  getLeafColumns(columns);
  return allLeafColumnDefs;
};
var prepareColumns = ({ aggregationFns: aggregationFns2, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns: filterFns2, sortingFns: sortingFns2 }) => columnDefs.map((columnDef) => {
  var _a, _b;
  if (!columnDef.id)
    columnDef.id = getColumnId(columnDef);
  if (!columnDef.id) {
    console.error("Column definitions must have a valid `accessorKey` or `id` property");
  }
  if (!columnDef.columnDefType)
    columnDef.columnDefType = "data";
  if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
    columnDef.columnDefType = "group";
    columnDef.columns = prepareColumns({
      aggregationFns: aggregationFns2,
      columnDefs: columnDef.columns,
      columnFilterFns,
      defaultDisplayColumn,
      filterFns: filterFns2,
      sortingFns: sortingFns2
    });
  } else if (columnDef.columnDefType === "data") {
    if (Array.isArray(columnDef.aggregationFn)) {
      const aggFns = columnDef.aggregationFn;
      columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => {
        var _a2;
        return (_a2 = aggregationFns2[fn]) === null || _a2 === void 0 ? void 0 : _a2.call(aggregationFns2, columnId, leafRows, childRows);
      });
    }
    if (Object.keys(filterFns2).includes(columnFilterFns[columnDef.id])) {
      columnDef.filterFn = (_b = filterFns2[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns2.fuzzy;
      columnDef._filterFn = columnFilterFns[columnDef.id];
    }
    if (Object.keys(sortingFns2).includes(columnDef.sortingFn)) {
      columnDef.sortingFn = sortingFns2[columnDef.sortingFn];
    }
  } else if (columnDef.columnDefType === "display") {
    columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
  }
  return columnDef;
});
var reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
  if (draggedColumn.getCanPin()) {
    draggedColumn.pin(targetColumn.getIsPinned());
  }
  columnOrder.splice(columnOrder.indexOf(targetColumn.id), 0, columnOrder.splice(columnOrder.indexOf(draggedColumn.id), 1)[0]);
  return [...columnOrder];
};
var showExpandColumn = (props2, grouping) => !!(props2.enableExpanding || props2.enableGrouping && (grouping === void 0 || (grouping === null || grouping === void 0 ? void 0 : grouping.length)) || props2.renderDetailPanel);
var getLeadingDisplayColumnIds = (props2) => {
  var _a;
  return [
    (props2.enableRowDragging || props2.enableRowOrdering) && "mrt-row-drag",
    props2.positionActionsColumn === "first" && (props2.enableRowActions || props2.enableEditing && ["row", "modal"].includes((_a = props2.editingMode) !== null && _a !== void 0 ? _a : "")) && "mrt-row-actions",
    props2.positionExpandColumn === "first" && showExpandColumn(props2) && "mrt-row-expand",
    props2.enableRowSelection && "mrt-row-select",
    props2.enableRowNumbers && "mrt-row-numbers"
  ].filter(Boolean);
};
var getTrailingDisplayColumnIds = (props2) => {
  var _a;
  return [
    props2.positionActionsColumn === "last" && (props2.enableRowActions || props2.enableEditing && ["row", "modal"].includes((_a = props2.editingMode) !== null && _a !== void 0 ? _a : "")) && "mrt-row-actions",
    props2.positionExpandColumn === "last" && showExpandColumn(props2) && "mrt-row-expand"
  ];
};
var getDefaultColumnOrderIds = (props2) => [
  ...getLeadingDisplayColumnIds(props2),
  ...getAllLeafColumnDefs(props2.columns).map((columnDef) => getColumnId(columnDef)),
  ...getTrailingDisplayColumnIds(props2)
].filter(Boolean);
var getDefaultColumnFilterFn = (columnDef) => {
  if (columnDef.filterVariant === "multi-select")
    return "arrIncludesSome";
  if (columnDef.filterVariant === "range")
    return "betweenInclusive";
  if (columnDef.filterVariant === "select" || columnDef.filterVariant === "checkbox")
    return "equals";
  return "fuzzy";
};
var getIsLastLeftPinnedColumn = (table, column) => {
  return column.getIsPinned() === "left" && table.getLeftLeafHeaders().length - 1 === column.getPinnedIndex();
};
var getIsFirstRightPinnedColumn = (column) => {
  return column.getIsPinned() === "right" && column.getPinnedIndex() === 0;
};
var getTotalRight = (table, column) => {
  return (table.getRightLeafHeaders().length - 1 - column.getPinnedIndex()) * 160;
};
var getCommonCellStyles = ({ column, header, table, tableCellProps, theme }) => {
  var _a, _b, _c, _d;
  return Object.assign(Object.assign({ backgroundColor: column.getIsPinned() && column.columnDef.columnDefType !== "group" ? alpha(lighten(theme.palette.background.default, 0.04), 0.97) : "inherit", backgroundImage: "inherit", boxShadow: getIsLastLeftPinnedColumn(table, column) ? `-4px 0 8px -6px ${alpha(theme.palette.common.black, 0.2)} inset` : getIsFirstRightPinnedColumn(column) ? `4px 0 8px -6px ${alpha(theme.palette.common.black, 0.2)} inset` : void 0, left: column.getIsPinned() === "left" ? `${column.getStart("left")}px` : void 0, opacity: ((_a = table.getState().draggingColumn) === null || _a === void 0 ? void 0 : _a.id) === column.id || ((_b = table.getState().hoveredColumn) === null || _b === void 0 ? void 0 : _b.id) === column.id ? 0.5 : 1, position: column.getIsPinned() && column.columnDef.columnDefType !== "group" ? "sticky" : void 0, right: column.getIsPinned() === "right" ? `${getTotalRight(table, column)}px` : void 0, transition: `all ${column.getIsResizing() ? 0 : "150ms"} ease-in-out` }, (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function ? tableCellProps.sx(theme) : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx), { maxWidth: `min(${column.getSize()}px, fit-content)`, minWidth: `max(${column.getSize()}px, ${(_c = column.columnDef.minSize) !== null && _c !== void 0 ? _c : 30}px)`, width: (_d = header === null || header === void 0 ? void 0 : header.getSize()) !== null && _d !== void 0 ? _d : column.getSize() });
};
var MRT_DefaultColumn = {
  minSize: 40,
  maxSize: 1e3,
  size: 180
};
var MRT_DefaultDisplayColumn = {
  columnDefType: "display",
  enableClickToCopy: false,
  enableColumnActions: false,
  enableColumnDragging: false,
  enableColumnFilter: false,
  enableColumnOrdering: false,
  enableEditing: false,
  enableGlobalFilter: false,
  enableGrouping: false,
  enableHiding: false,
  enableResizing: false,
  enableSorting: false
};
var fuzzy$1 = (row, columnId, filterValue, addMeta) => {
  const itemRank = rankItem(row.getValue(columnId), filterValue, {
    threshold: rankings.MATCHES
  });
  addMeta(itemRank);
  return itemRank.passed;
};
fuzzy$1.autoRemove = (val) => !val;
var contains = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
var startsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
var endsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
var equals2 = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() === filterValue.toString().toLowerCase().trim();
equals2.autoRemove = (val) => !val;
var notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !== filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
var greaterThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) > +filterValue : row.getValue(id).toString().toLowerCase().trim() > filterValue.toString().toLowerCase().trim();
greaterThan.autoRemove = (val) => !val;
var greaterThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
var lessThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) < +filterValue : row.getValue(id).toString().toLowerCase().trim() < filterValue.toString().toLowerCase().trim();
lessThan.autoRemove = (val) => !val;
var lessThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
var between = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThan(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
var betweenInclusive = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThanOrEqualTo(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
var empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
var notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
var MRT_FilterFns = Object.assign(Object.assign({}, filterFns), {
  between,
  betweenInclusive,
  contains,
  empty,
  endsWith,
  equals: equals2,
  fuzzy: fuzzy$1,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  notEmpty,
  notEquals,
  startsWith
});
var MRT_Default_Icons = {
  ArrowDownwardIcon: import_ArrowDownward.default,
  ArrowRightIcon: import_ArrowRight.default,
  CancelIcon: import_Cancel.default,
  CheckBoxIcon: import_CheckBox.default,
  ClearAllIcon: import_ClearAll.default,
  CloseIcon: import_Close.default,
  DensityLargeIcon: import_DensityLarge.default,
  DensityMediumIcon: import_DensityMedium.default,
  DensitySmallIcon: import_DensitySmall.default,
  DragHandleIcon: import_DragHandle.default,
  DynamicFeedIcon: import_DynamicFeed.default,
  EditIcon: import_Edit.default,
  ExpandLessIcon: import_ExpandLess.default,
  ExpandMoreIcon: import_ExpandMore.default,
  FilterAltIcon: import_FilterAlt.default,
  FilterAltOffIcon: import_FilterAltOff.default,
  FilterListIcon: import_FilterList.default,
  FilterListOffIcon: import_FilterListOff.default,
  FullscreenExitIcon: import_FullscreenExit.default,
  FullscreenIcon: import_Fullscreen.default,
  KeyboardDoubleArrowDownIcon: import_KeyboardDoubleArrowDown.default,
  MoreHorizIcon: import_MoreHoriz.default,
  MoreVertIcon: import_MoreVert.default,
  PushPinIcon: import_PushPin.default,
  RestartAltIcon: import_RestartAlt.default,
  SaveIcon: import_Save.default,
  SearchIcon: import_Search.default,
  SearchOffIcon: import_SearchOff.default,
  SortIcon: import_Sort.default,
  ViewColumnIcon: import_ViewColumn.default,
  VisibilityOffIcon: import_VisibilityOff.default
};
var fuzzy = (rowA, rowB, columnId) => {
  let dir = 0;
  if (rowA.columnFiltersMeta[columnId]) {
    dir = compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
  }
  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;
};
var MRT_SortingFns = Object.assign(Object.assign({}, sortingFns), { fuzzy });
var rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) - Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));
var MRT_ExpandAllButton = ({ table }) => {
  var _a;
  const { getIsAllRowsExpanded, getIsSomeRowsExpanded, getCanSomeRowsExpand, getState, options: { icons: { KeyboardDoubleArrowDownIcon: KeyboardDoubleArrowDownIcon2 }, localization, muiExpandAllButtonProps, renderDetailPanel }, toggleAllRowsExpanded } = table;
  const { density, isLoading } = getState();
  const iconButtonProps = muiExpandAllButtonProps instanceof Function ? muiExpandAllButtonProps({ table }) : muiExpandAllButtonProps;
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.expandAll },
    import_react2.default.createElement(
      "span",
      null,
      import_react2.default.createElement(
        IconButton_default,
        Object.assign({ "aria-label": localization.expandAll, disabled: isLoading || !renderDetailPanel && !getCanSomeRowsExpand(), onClick: () => toggleAllRowsExpanded(!getIsAllRowsExpanded()) }, iconButtonProps, { sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", width: density === "compact" ? "1.75rem" : "2.25rem", mt: density !== "compact" ? "-0.25rem" : void 0 }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0 }),
        import_react2.default.createElement(KeyboardDoubleArrowDownIcon2, { style: {
          transform: `rotate(${getIsAllRowsExpanded() ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,
          transition: "transform 150ms"
        } })
      )
    )
  );
};
var MRT_ExpandButton = ({ row, table }) => {
  var _a;
  const { getState, options: { icons: { ExpandMoreIcon: ExpandMoreIcon2 }, localization, muiExpandButtonProps, renderDetailPanel } } = table;
  const { density } = getState();
  const iconButtonProps = muiExpandButtonProps instanceof Function ? muiExpandButtonProps({ table, row }) : muiExpandButtonProps;
  const handleToggleExpand = (event) => {
    var _a2;
    event.stopPropagation();
    row.toggleExpanded();
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
  };
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.expand },
    import_react2.default.createElement(
      "span",
      null,
      import_react2.default.createElement(
        IconButton_default,
        Object.assign({ "aria-label": localization.expand, disabled: !row.getCanExpand() && !renderDetailPanel }, iconButtonProps, { onClick: handleToggleExpand, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", width: density === "compact" ? "1.75rem" : "2.25rem" }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0 }),
        import_react2.default.createElement(ExpandMoreIcon2, { style: {
          transform: `rotate(${!row.getCanExpand() && !renderDetailPanel ? -90 : row.getIsExpanded() ? -180 : 0}deg)`,
          transition: "transform 150ms"
        } })
      )
    )
  );
};
var mrtFilterOptions = (localization) => [
  {
    option: "fuzzy",
    symbol: "\u2248",
    label: localization.filterFuzzy,
    divider: false
  },
  {
    option: "contains",
    symbol: "*",
    label: localization.filterContains,
    divider: false
  },
  {
    option: "startsWith",
    symbol: "a",
    label: localization.filterStartsWith,
    divider: false
  },
  {
    option: "endsWith",
    symbol: "z",
    label: localization.filterEndsWith,
    divider: true
  },
  {
    option: "equals",
    symbol: "=",
    label: localization.filterEquals,
    divider: false
  },
  {
    option: "notEquals",
    symbol: "\u2260",
    label: localization.filterNotEquals,
    divider: true
  },
  {
    option: "between",
    symbol: "\u21FF",
    label: localization.filterBetween,
    divider: false
  },
  {
    option: "betweenInclusive",
    symbol: "\u2B0C",
    label: localization.filterBetweenInclusive,
    divider: true
  },
  {
    option: "greaterThan",
    symbol: ">",
    label: localization.filterGreaterThan,
    divider: false
  },
  {
    option: "greaterThanOrEqualTo",
    symbol: "\u2265",
    label: localization.filterGreaterThanOrEqualTo,
    divider: false
  },
  {
    option: "lessThan",
    symbol: "<",
    label: localization.filterLessThan,
    divider: false
  },
  {
    option: "lessThanOrEqualTo",
    symbol: "\u2264",
    label: localization.filterLessThanOrEqualTo,
    divider: true
  },
  {
    option: "empty",
    symbol: "\u2205",
    label: localization.filterEmpty,
    divider: false
  },
  {
    option: "notEmpty",
    symbol: "!\u2205",
    label: localization.filterNotEmpty,
    divider: false
  }
];
var MRT_FilterOptionMenu = ({ anchorEl, header, onSelect, setAnchorEl, setFilterValue, table }) => {
  var _a, _b, _c, _d;
  const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems }, setColumnFilterFns, setGlobalFilterFn } = table;
  const { globalFilterFn, density } = getState();
  const { column } = header !== null && header !== void 0 ? header : {};
  const { columnDef } = column !== null && column !== void 0 ? column : {};
  const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
  const internalFilterOptions = (0, import_react2.useMemo)(() => mrtFilterOptions(localization).filter((filterOption2) => columnDef ? allowedColumnFilterOptions === void 0 || (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption2.option)) : (!globalFilterModeOptions || globalFilterModeOptions.includes(filterOption2.option)) && ["fuzzy", "contains", "startsWith"].includes(filterOption2.option)), []);
  const handleSelectFilterMode = (option) => {
    if (header && column) {
      setColumnFilterFns((prev) => Object.assign(Object.assign({}, prev), { [header.id]: option }));
      if (["empty", "notEmpty"].includes(option)) {
        column.setFilterValue(" ");
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "multi-select" || ["arrIncludesSome", "arrIncludesAll", "arrIncludes"].includes(option)) {
        column.setFilterValue([]);
        setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "range" || ["between", "betweenInclusive", "inNumberRange"].includes(option)) {
        column.setFilterValue(["", ""]);
        setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
      } else {
        column.setFilterValue("");
        setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
      }
    } else {
      setGlobalFilterFn(option);
    }
    setAnchorEl(null);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect();
  };
  const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
  return import_react2.default.createElement(Menu_default, { anchorEl, anchorOrigin: { vertical: "center", horizontal: "right" }, onClose: () => setAnchorEl(null), open: !!anchorEl, MenuListProps: {
    dense: density === "compact"
  } }, (_d = header && column && columnDef ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  }) : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ option, label, divider, symbol }, index) => import_react2.default.createElement(
    MenuItem_default,
    { divider, key: index, onClick: () => handleSelectFilterMode(option), selected: option === filterOption, sx: {
      alignItems: "center",
      display: "flex",
      gap: "2ch",
      my: 0,
      py: "6px"
    }, value: option },
    import_react2.default.createElement(Box_default, { sx: { fontSize: "1.25rem", width: "2ch" } }, symbol),
    label
  )));
};
var MRT_ColumnPinningButtons = ({ column, table }) => {
  const { options: { icons: { PushPinIcon: PushPinIcon2 }, localization } } = table;
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
  };
  return import_react2.default.createElement(Box_default, { sx: { minWidth: "70px", textAlign: "center" } }, column.getIsPinned() ? import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, title: localization.unpin },
    import_react2.default.createElement(
      IconButton_default,
      { onClick: () => handlePinColumn(false), size: "small" },
      import_react2.default.createElement(PushPinIcon2, null)
    )
  ) : import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, title: localization.pinToLeft },
      import_react2.default.createElement(
        IconButton_default,
        { onClick: () => handlePinColumn("left"), size: "small" },
        import_react2.default.createElement(PushPinIcon2, { style: {
          transform: "rotate(90deg)"
        } })
      )
    ),
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, title: localization.pinToRight },
      import_react2.default.createElement(
        IconButton_default,
        { onClick: () => handlePinColumn("right"), size: "small" },
        import_react2.default.createElement(PushPinIcon2, { style: {
          transform: "rotate(-90deg)"
        } })
      )
    )
  ));
};
var MRT_GrabHandleButton = ({ iconButtonProps, onDragEnd, onDragStart, table }) => {
  var _a;
  const { options: { icons: { DragHandleIcon: DragHandleIcon2 }, localization } } = table;
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.move },
    import_react2.default.createElement(
      IconButton_default,
      Object.assign({ disableRipple: true, draggable: "true", size: "small" }, iconButtonProps, { onClick: (e) => {
        var _a2;
        e.stopPropagation();
        (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, e);
      }, onDragStart, onDragEnd, sx: (theme) => Object.assign({ cursor: "grab", m: "0 -0.1rem", opacity: 0.5, p: "2px", transition: "all 150ms ease-in-out", "&:hover": {
        backgroundColor: "transparent",
        opacity: 1
      }, "&:active": {
        cursor: "grabbing"
      } }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0 }),
      import_react2.default.createElement(DragHandleIcon2, null)
    )
  );
};
var MRT_ShowHideColumnsMenuItems = ({ allColumns, hoveredColumn, setHoveredColumn, column, isSubMenu, table }) => {
  var _a;
  const { getState, options: { enableColumnOrdering, enableHiding, enablePinning, localization }, setColumnOrder } = table;
  const { columnOrder } = getState();
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const switchChecked = columnDefType !== "group" && column.getIsVisible() || columnDefType === "group" && column.getLeafColumns().some((col) => col.getIsVisible());
  const handleToggleColumnHidden = (column2) => {
    var _a2, _b;
    if (columnDefType === "group") {
      (_b = (_a2 = column2 === null || column2 === void 0 ? void 0 : column2.columns) === null || _a2 === void 0 ? void 0 : _a2.forEach) === null || _b === void 0 ? void 0 : _b.call(_a2, (childColumn) => {
        childColumn.toggleVisibility(!switchChecked);
      });
    } else {
      column2.toggleVisibility();
    }
  };
  const menuItemRef = (0, import_react2.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react2.useState)(false);
  const handleDragStart = (e) => {
    setIsDragging(true);
    e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
  };
  const handleDragEnd = (_e) => {
    setIsDragging(false);
    setHoveredColumn(null);
    if (hoveredColumn) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
  };
  const handleDragEnter = (_e) => {
    if (!isDragging && columnDef.enableColumnOrdering !== false) {
      setHoveredColumn(column);
    }
  };
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      MenuItem_default,
      { disableRipple: true, ref: menuItemRef, onDragEnter: handleDragEnter, sx: (theme) => ({
        alignItems: "center",
        justifyContent: "flex-start",
        my: 0,
        opacity: isDragging ? 0.5 : 1,
        outline: isDragging ? `1px dashed ${theme.palette.divider}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${theme.palette.primary.main}` : "none",
        pl: `${(column.depth + 0.5) * 2}rem`,
        py: "6px"
      }) },
      import_react2.default.createElement(
        Box_default,
        { sx: {
          display: "flex",
          flexWrap: "nowrap",
          gap: "8px"
        } },
        !isSubMenu && columnDefType !== "group" && enableColumnOrdering && !allColumns.some((col) => col.columnDef.columnDefType === "group") && (columnDef.enableColumnOrdering !== false ? import_react2.default.createElement(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }) : import_react2.default.createElement(Box_default, { sx: { width: "28px" } })),
        !isSubMenu && enablePinning && (column.getCanPin() ? import_react2.default.createElement(MRT_ColumnPinningButtons, { column, table }) : import_react2.default.createElement(Box_default, { sx: { width: "70px" } })),
        enableHiding ? import_react2.default.createElement(FormControlLabel_default, { componentsProps: {
          typography: {
            sx: {
              mb: 0,
              opacity: columnDefType !== "display" ? 1 : 0.5
            }
          }
        }, checked: switchChecked, control: import_react2.default.createElement(
          Tooltip_default,
          { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: localization.toggleVisibility },
          import_react2.default.createElement(Switch_default, null)
        ), disabled: isSubMenu && switchChecked || !column.getCanHide() || column.getIsGrouped(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column) }) : import_react2.default.createElement(Typography_default, { sx: { alignSelf: "center" } }, columnDef.header)
      )
    ),
    (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => import_react2.default.createElement(MRT_ShowHideColumnsMenuItems, { allColumns, column: c, hoveredColumn, isSubMenu, key: `${i}-${c.id}`, setHoveredColumn, table }))
  );
};
var MRT_ShowHideColumnsMenu = ({ anchorEl, isSubMenu, setAnchorEl, table }) => {
  const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, toggleAllColumnsVisible, options: { localization, enablePinning, enableColumnOrdering } } = table;
  const { density, columnOrder, columnPinning } = getState();
  const hideAllColumns = () => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(false));
  };
  const allColumns = (0, import_react2.useMemo)(() => {
    const columns = getAllColumns();
    if (columnOrder.length > 0 && !columns.some((col) => col.columnDef.columnDefType === "group")) {
      return [
        ...getLeftLeafColumns(),
        ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
        ...getRightLeafColumns()
      ].filter(Boolean);
    }
    return columns;
  }, [
    columnOrder,
    columnPinning,
    getAllColumns(),
    getCenterLeafColumns(),
    getLeftLeafColumns(),
    getRightLeafColumns()
  ]);
  const [hoveredColumn, setHoveredColumn] = (0, import_react2.useState)(null);
  return import_react2.default.createElement(
    Menu_default,
    { anchorEl, open: !!anchorEl, onClose: () => setAnchorEl(null), MenuListProps: {
      dense: density === "compact"
    } },
    import_react2.default.createElement(
      Box_default,
      { sx: {
        display: "flex",
        justifyContent: isSubMenu ? "center" : "space-between",
        p: "0.5rem",
        pt: 0
      } },
      !isSubMenu && import_react2.default.createElement(Button_default, { disabled: !getIsSomeColumnsVisible(), onClick: hideAllColumns }, localization.hideAll),
      !isSubMenu && enableColumnOrdering && import_react2.default.createElement(Button_default, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)) }, localization.resetOrder),
      !isSubMenu && enablePinning && import_react2.default.createElement(Button_default, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true) }, localization.unpinAll),
      import_react2.default.createElement(Button_default, { disabled: getIsAllColumnsVisible(), onClick: () => toggleAllColumnsVisible(true) }, localization.showAll)
    ),
    import_react2.default.createElement(Divider_default, null),
    allColumns.map((column, index) => import_react2.default.createElement(MRT_ShowHideColumnsMenuItems, { allColumns, column, hoveredColumn, isSubMenu, key: `${index}-${column.id}`, setHoveredColumn, table }))
  );
};
var commonMenuItemStyles = {
  py: "6px",
  my: 0,
  justifyContent: "space-between",
  alignItems: "center"
};
var commonListItemStyles = {
  display: "flex",
  alignItems: "center"
};
var MRT_ColumnActionMenu = ({ anchorEl, header, setAnchorEl, table }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const { getState, toggleAllColumnsVisible, setColumnOrder, options: { columnFilterModeOptions, enableColumnFilterModes, enableColumnFilters, enableColumnResizing, enableGrouping, enableHiding, enablePinning, enableSorting, icons: { ArrowRightIcon: ArrowRightIcon2, ClearAllIcon: ClearAllIcon2, ViewColumnIcon: ViewColumnIcon2, DynamicFeedIcon: DynamicFeedIcon2, FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2, PushPinIcon: PushPinIcon2, SortIcon: SortIcon2, RestartAltIcon: RestartAltIcon2, VisibilityOffIcon: VisibilityOffIcon2 }, localization, renderColumnActionsMenuItems }, refs: { filterInputRefs }, setShowFilters } = table;
  const { column } = header;
  const { columnDef } = column;
  const { columnSizing, columnVisibility, density } = getState();
  const [filterMenuAnchorEl, setFilterMenuAnchorEl] = (0, import_react2.useState)(null);
  const [showHideColumnsMenuAnchorEl, setShowHideColumnsMenuAnchorEl] = (0, import_react2.useState)(null);
  const handleClearSort = () => {
    column.clearSorting();
    setAnchorEl(null);
  };
  const handleSortAsc = () => {
    column.toggleSorting(false);
    setAnchorEl(null);
  };
  const handleSortDesc = () => {
    column.toggleSorting(true);
    setAnchorEl(null);
  };
  const handleResetColumnSize = () => {
    column.resetSize();
    setAnchorEl(null);
  };
  const handleHideColumn = () => {
    column.toggleVisibility(false);
    setAnchorEl(null);
  };
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
    setAnchorEl(null);
  };
  const handleGroupByColumn = () => {
    column.toggleGrouping();
    setColumnOrder((old) => ["mrt-row-expand", ...old]);
    setAnchorEl(null);
  };
  const handleClearFilter = () => {
    column.setFilterValue("");
    setAnchorEl(null);
  };
  const handleFilterByColumn = () => {
    setShowFilters(true);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = filterInputRefs.current[`${column.id}-0`]) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
    setAnchorEl(null);
  };
  const handleShowAllColumns = () => {
    toggleAllColumnsVisible(true);
    setAnchorEl(null);
  };
  const handleOpenFilterModeMenu = (event) => {
    event.stopPropagation();
    setFilterMenuAnchorEl(event.currentTarget);
  };
  const handleOpenShowHideColumnsMenu = (event) => {
    event.stopPropagation();
    setShowHideColumnsMenuAnchorEl(event.currentTarget);
  };
  const isSelectFilter = !!columnDef.filterSelectOptions;
  const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
  const showFilterModeSubMenu = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !isSelectFilter && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  return import_react2.default.createElement(
    Menu_default,
    { anchorEl, open: !!anchorEl, onClose: () => setAnchorEl(null), MenuListProps: {
      dense: density === "compact"
    } },
    (_d = (_c = (_b = columnDef.renderColumnActionsMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
      closeMenu: () => setAnchorEl(null),
      column,
      table
    })) !== null && _c !== void 0 ? _c : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
      closeMenu: () => setAnchorEl(null),
      column,
      table
    })) !== null && _d !== void 0 ? _d : enableSorting && column.getCanSort() && [
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: !column.getIsSorted(), key: 0, onClick: handleClearSort, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(ClearAllIcon2, null)
          ),
          localization.clearSort
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: column.getIsSorted() === "asc", key: 1, onClick: handleSortAsc, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(SortIcon2, { style: { transform: "rotate(180deg) scaleX(-1)" } })
          ),
          (_e = localization.sortByColumnAsc) === null || _e === void 0 ? void 0 : _e.replace("{column}", String(columnDef.header))
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { divider: enableColumnFilters || enableGrouping || enableHiding, key: 2, disabled: column.getIsSorted() === "desc", onClick: handleSortDesc, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(SortIcon2, null)
          ),
          (_f = localization.sortByColumnDesc) === null || _f === void 0 ? void 0 : _f.replace("{column}", String(columnDef.header))
        )
      )
    ],
    enableColumnFilters && column.getCanFilter() && [
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: !column.getFilterValue(), key: 0, onClick: handleClearFilter, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(FilterListOffIcon2, null)
          ),
          localization.clearFilter
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { divider: enableGrouping || enableHiding, key: 1, onClick: handleFilterByColumn, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(FilterListIcon2, null)
          ),
          (_g = localization.filterByColumn) === null || _g === void 0 ? void 0 : _g.replace("{column}", String(columnDef.header))
        ),
        showFilterModeSubMenu && import_react2.default.createElement(
          IconButton_default,
          { onClick: handleOpenFilterModeMenu, onMouseEnter: handleOpenFilterModeMenu, size: "small", sx: { p: 0 } },
          import_react2.default.createElement(ArrowRightIcon2, null)
        )
      ),
      showFilterModeSubMenu && import_react2.default.createElement(MRT_FilterOptionMenu, { anchorEl: filterMenuAnchorEl, header, key: 2, onSelect: handleFilterByColumn, setAnchorEl: setFilterMenuAnchorEl, table })
    ].filter(Boolean),
    enableGrouping && column.getCanGroup() && [
      import_react2.default.createElement(
        MenuItem_default,
        { divider: enablePinning, key: 0, onClick: handleGroupByColumn, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(DynamicFeedIcon2, null)
          ),
          (_h = localization[column.getIsGrouped() ? "ungroupByColumn" : "groupByColumn"]) === null || _h === void 0 ? void 0 : _h.replace("{column}", String(columnDef.header))
        )
      )
    ],
    enablePinning && column.getCanPin() && [
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: column.getIsPinned() === "left" || !column.getCanPin(), key: 0, onClick: () => handlePinColumn("left"), sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(PushPinIcon2, { style: { transform: "rotate(90deg)" } })
          ),
          localization.pinToLeft
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: column.getIsPinned() === "right" || !column.getCanPin(), key: 1, onClick: () => handlePinColumn("right"), sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(PushPinIcon2, { style: { transform: "rotate(-90deg)" } })
          ),
          localization.pinToRight
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: !column.getIsPinned(), divider: enableHiding, key: 2, onClick: () => handlePinColumn(false), sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(PushPinIcon2, null)
          ),
          localization.unpin
        )
      )
    ],
    enableColumnResizing && column.getCanResize() && [
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: !columnSizing[column.id], key: 0, onClick: handleResetColumnSize, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(RestartAltIcon2, null)
          ),
          localization.resetColumnSize
        )
      )
    ],
    enableHiding && [
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: columnDef.enableHiding === false, key: 0, onClick: handleHideColumn, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(VisibilityOffIcon2, null)
          ),
          (_j = localization.hideColumn) === null || _j === void 0 ? void 0 : _j.replace("{column}", String(columnDef.header))
        )
      ),
      import_react2.default.createElement(
        MenuItem_default,
        { disabled: !Object.values(columnVisibility).filter((visible) => !visible).length, key: 1, onClick: handleShowAllColumns, sx: commonMenuItemStyles },
        import_react2.default.createElement(
          Box_default,
          { sx: commonListItemStyles },
          import_react2.default.createElement(
            ListItemIcon_default,
            null,
            import_react2.default.createElement(ViewColumnIcon2, null)
          ),
          (_k = localization.showAllColumns) === null || _k === void 0 ? void 0 : _k.replace("{column}", String(columnDef.header))
        ),
        import_react2.default.createElement(
          IconButton_default,
          { onClick: handleOpenShowHideColumnsMenu, onMouseEnter: handleOpenShowHideColumnsMenu, size: "small", sx: { p: 0 } },
          import_react2.default.createElement(ArrowRightIcon2, null)
        )
      ),
      import_react2.default.createElement(MRT_ShowHideColumnsMenu, { anchorEl: showHideColumnsMenuAnchorEl, isSubMenu: true, key: 2, setAnchorEl: setShowHideColumnsMenuAnchorEl, table })
    ]
  );
};
var MRT_RowActionMenu = ({ anchorEl, handleEdit, row, setAnchorEl, table }) => {
  const { getState, options: { icons: { EditIcon: EditIcon2 }, enableEditing, localization, renderRowActionMenuItems } } = table;
  const { density } = getState();
  return import_react2.default.createElement(
    Menu_default,
    { anchorEl, open: !!anchorEl, onClose: () => setAnchorEl(null), MenuListProps: {
      dense: density === "compact"
    } },
    enableEditing && import_react2.default.createElement(
      MenuItem_default,
      { onClick: handleEdit, sx: commonMenuItemStyles },
      import_react2.default.createElement(
        Box_default,
        { sx: commonListItemStyles },
        import_react2.default.createElement(
          ListItemIcon_default,
          null,
          import_react2.default.createElement(EditIcon2, null)
        ),
        localization.edit
      )
    ),
    renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
      row,
      table,
      closeMenu: () => setAnchorEl(null)
    })
  );
};
var MRT_EditActionButtons = ({ row, table, variant = "icon" }) => {
  const { getState, options: { icons: { CancelIcon: CancelIcon2, SaveIcon: SaveIcon2 }, localization, onEditingRowSave }, refs: { editInputRefs }, setEditingRow } = table;
  const { editingRow } = getState();
  const handleCancel = () => setEditingRow(null);
  const handleSave = () => {
    var _a, _b;
    (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)) === null || _a === void 0 ? void 0 : _a.forEach((input) => {
      if (input.value !== void 0 && Object.hasOwn(editingRow === null || editingRow === void 0 ? void 0 : editingRow._valuesCache, input.name)) {
        editingRow._valuesCache[input.name] = input.value;
      }
    });
    onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
      exitEditingMode: () => setEditingRow(null),
      row: editingRow !== null && editingRow !== void 0 ? editingRow : row,
      table,
      values: (_b = editingRow === null || editingRow === void 0 ? void 0 : editingRow._valuesCache) !== null && _b !== void 0 ? _b : Object.assign({}, row.original)
    });
  };
  return import_react2.default.createElement(Box_default, { onClick: (e) => e.stopPropagation(), sx: { display: "flex", gap: "0.75rem" } }, variant === "icon" ? import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, title: localization.cancel },
      import_react2.default.createElement(
        IconButton_default,
        { "aria-label": localization.cancel, onClick: handleCancel },
        import_react2.default.createElement(CancelIcon2, null)
      )
    ),
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, title: localization.save },
      import_react2.default.createElement(
        IconButton_default,
        { "aria-label": localization.save, color: "info", onClick: handleSave },
        import_react2.default.createElement(SaveIcon2, null)
      )
    )
  ) : import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Button_default, { onClick: handleCancel }, localization.cancel),
    import_react2.default.createElement(Button_default, { onClick: handleSave, variant: "contained" }, localization.save)
  ));
};
var commonIconButtonStyles = {
  height: "2rem",
  ml: "10px",
  opacity: 0.5,
  transition: "opacity 150ms",
  width: "2rem",
  "&:hover": {
    opacity: 1
  }
};
var MRT_ToggleRowActionMenuButton = ({ cell, row, table }) => {
  const { getState, options: { editingMode, enableEditing, icons: { EditIcon: EditIcon2, MoreHorizIcon: MoreHorizIcon2 }, localization, renderRowActionMenuItems, renderRowActions }, setEditingRow } = table;
  const { editingRow } = getState();
  const [anchorEl, setAnchorEl] = (0, import_react2.useState)(null);
  const handleOpenRowActionMenu = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const handleStartEditMode = (event) => {
    event.stopPropagation();
    setEditingRow(Object.assign({}, row));
    setAnchorEl(null);
  };
  return import_react2.default.createElement(import_react2.default.Fragment, null, renderRowActions ? import_react2.default.createElement(import_react2.default.Fragment, null, renderRowActions({ cell, row, table })) : row.id === (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) && editingMode === "row" ? import_react2.default.createElement(MRT_EditActionButtons, { row, table }) : !renderRowActionMenuItems && enableEditing ? import_react2.default.createElement(
    Tooltip_default,
    { placement: "right", arrow: true, title: localization.edit },
    import_react2.default.createElement(
      IconButton_default,
      { "aria-label": localization.edit, sx: commonIconButtonStyles, onClick: handleStartEditMode },
      import_react2.default.createElement(EditIcon2, null)
    )
  ) : renderRowActionMenuItems ? import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: localization.rowActions },
      import_react2.default.createElement(
        IconButton_default,
        { "aria-label": localization.rowActions, onClick: handleOpenRowActionMenu, size: "small", sx: commonIconButtonStyles },
        import_react2.default.createElement(MoreHorizIcon2, null)
      )
    ),
    import_react2.default.createElement(MRT_RowActionMenu, { anchorEl, handleEdit: handleStartEditMode, row, setAnchorEl, table })
  ) : null);
};
var MRT_SelectCheckbox = ({ row, selectAll, table }) => {
  var _a;
  const { getState, options: { localization, enableMultiRowSelection, muiSelectCheckboxProps, muiSelectAllCheckboxProps, selectAllMode } } = table;
  const { density, isLoading } = getState();
  const checkboxProps = !row ? muiSelectAllCheckboxProps instanceof Function ? muiSelectAllCheckboxProps({ table }) : muiSelectAllCheckboxProps : muiSelectCheckboxProps instanceof Function ? muiSelectCheckboxProps({ row, table }) : muiSelectCheckboxProps;
  const commonProps = Object.assign(Object.assign({ checked: selectAll ? selectAllMode === "page" ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected() : row === null || row === void 0 ? void 0 : row.getIsSelected(), disabled: isLoading, inputProps: {
    "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow
  }, onChange: row ? row.getToggleSelectedHandler() : selectAllMode === "all" ? table.getToggleAllRowsSelectedHandler() : table.getToggleAllPageRowsSelectedHandler(), size: density === "compact" ? "small" : "medium" }, checkboxProps), { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
  }, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.5rem", width: density === "compact" ? "1.75rem" : "2.5rem", m: density !== "compact" ? "-0.4rem" : void 0 }, (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function ? checkboxProps.sx(theme) : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx), title: void 0 });
  return import_react2.default.createElement(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _a !== void 0 ? _a : selectAll ? localization.toggleSelectAll : localization.toggleSelectRow }, enableMultiRowSelection === false ? import_react2.default.createElement(Radio_default, Object.assign({}, commonProps)) : import_react2.default.createElement(Checkbox_default, Object.assign({ indeterminate: selectAll ? table.getIsSomeRowsSelected() && !(selectAllMode === "page" ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected()) : row === null || row === void 0 ? void 0 : row.getIsSomeSelected() }, commonProps)));
};
var MRT_GlobalFilterTextField = ({ table }) => {
  var _a;
  const { getState, setGlobalFilter, options: { enableGlobalFilterModes, icons: { SearchIcon: SearchIcon2, CloseIcon: CloseIcon2 }, localization, manualFiltering, muiSearchTextFieldProps }, refs: { searchInputRef } } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const textFieldProps = muiSearchTextFieldProps instanceof Function ? muiSearchTextFieldProps({ table }) : muiSearchTextFieldProps;
  const [anchorEl, setAnchorEl] = (0, import_react2.useState)(null);
  const [searchValue, setSearchValue] = (0, import_react2.useState)(globalFilter !== null && globalFilter !== void 0 ? globalFilter : "");
  const handleChangeDebounced = (0, import_react2.useCallback)((0, import_debounce.default)((event) => {
    var _a2;
    setGlobalFilter((_a2 = event.target.value) !== null && _a2 !== void 0 ? _a2 : void 0);
  }, manualFiltering ? 500 : 250), []);
  const handleChange = (event) => {
    setSearchValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleGlobalFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClear = () => {
    setSearchValue("");
    setGlobalFilter(void 0);
  };
  (0, import_react2.useEffect)(() => {
    if (globalFilter === void 0) {
      handleClear();
    }
  }, [globalFilter]);
  return import_react2.default.createElement(
    Collapse_default,
    { in: showGlobalFilter, orientation: "horizontal", unmountOnExit: true, mountOnEnter: true },
    import_react2.default.createElement(TextField_default, Object.assign({ placeholder: localization.search, onChange: handleChange, value: searchValue !== null && searchValue !== void 0 ? searchValue : "", variant: "standard", InputProps: {
      startAdornment: enableGlobalFilterModes ? import_react2.default.createElement(
        InputAdornment_default,
        { position: "start" },
        import_react2.default.createElement(
          Tooltip_default,
          { arrow: true, title: localization.changeSearchMode },
          import_react2.default.createElement(
            IconButton_default,
            { "aria-label": localization.changeSearchMode, onClick: handleGlobalFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" } },
            import_react2.default.createElement(SearchIcon2, null)
          )
        )
      ) : import_react2.default.createElement(SearchIcon2, { style: { marginRight: "4px" } }),
      endAdornment: import_react2.default.createElement(
        InputAdornment_default,
        { position: "end" },
        import_react2.default.createElement(
          Tooltip_default,
          { arrow: true, title: (_a = localization.clearSearch) !== null && _a !== void 0 ? _a : "" },
          import_react2.default.createElement(
            "span",
            null,
            import_react2.default.createElement(
              IconButton_default,
              { "aria-label": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "small" },
              import_react2.default.createElement(CloseIcon2, null)
            )
          )
        )
      )
    } }, textFieldProps, { inputRef: (inputRef) => {
      searchInputRef.current = inputRef;
      if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {
        textFieldProps.inputRef = inputRef;
      }
    } })),
    import_react2.default.createElement(MRT_FilterOptionMenu, { anchorEl, setAnchorEl, table, onSelect: handleClear })
  );
};
var MRT_LinearProgressBar = ({ isTopToolbar, table }) => {
  const { options: { muiLinearProgressProps }, getState } = table;
  const { isLoading, showProgressBars } = getState();
  const linearProgressProps = muiLinearProgressProps instanceof Function ? muiLinearProgressProps({ isTopToolbar, table }) : muiLinearProgressProps;
  return import_react2.default.createElement(
    Collapse_default,
    { in: isLoading || showProgressBars, mountOnEnter: true, unmountOnExit: true, sx: {
      bottom: isTopToolbar ? 0 : void 0,
      position: "absolute",
      top: !isTopToolbar ? 0 : void 0,
      width: "100%"
    } },
    import_react2.default.createElement(LinearProgress_default, Object.assign({ "aria-label": "Loading", "aria-busy": "true", sx: { position: "relative" } }, linearProgressProps))
  );
};
var MRT_TablePagination = ({ table, position }) => {
  const { getPrePaginationRowModel, getState, setPageIndex, setPageSize, options: { muiTablePaginationProps, enableToolbarInternalActions, localization, rowCount } } = table;
  const { pagination: { pageSize = 10, pageIndex = 0 }, showGlobalFilter } = getState();
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
  const showFirstLastPageButtons = totalRowCount / pageSize > 2;
  const tablePaginationProps = muiTablePaginationProps instanceof Function ? muiTablePaginationProps({ table }) : muiTablePaginationProps;
  const handleChangeRowsPerPage = (event) => {
    setPageSize(+event.target.value);
  };
  return import_react2.default.createElement(TablePagination_default, Object.assign({ component: "div", count: totalRowCount, getItemAriaLabel: (type) => type === "first" ? localization.goToFirstPage : type === "last" ? localization.goToLastPage : type === "next" ? localization.goToNextPage : localization.goToPreviousPage, labelDisplayedRows: ({ from, to, count: count2 }) => `${from}-${to} ${localization.of} ${count2}`, labelRowsPerPage: localization.rowsPerPage, onPageChange: (_, newPage) => setPageIndex(newPage), onRowsPerPageChange: handleChangeRowsPerPage, page: pageIndex, rowsPerPage: pageSize, rowsPerPageOptions: [5, 10, 15, 20, 25, 30, 50, 100], showFirstButton: showFirstLastPageButtons, showLastButton: showFirstLastPageButtons }, tablePaginationProps, { SelectProps: Object.assign({ sx: { m: "0 1rem 0 1ch" }, MenuProps: { MenuListProps: { disablePadding: true }, sx: { m: 0 } } }, tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.SelectProps), sx: (theme) => Object.assign({ "& .MuiTablePagination-toolbar": {
    display: "flex",
    alignItems: "center"
  }, "& .MuiTablePagination-selectLabel": {
    m: "0 -1px"
  }, "&. MuiInputBase-root": {
    m: "0 1px"
  }, "& . MuiTablePagination-select": {
    m: "0 1px"
  }, "& .MuiTablePagination-displayedRows": {
    m: "0 1px"
  }, "& .MuiTablePagination-actions": {
    m: "0 1px"
  }, mt: position === "top" && enableToolbarInternalActions && !showGlobalFilter ? "3.5rem" : void 0, position: "relative", zIndex: 2 }, (tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.sx) instanceof Function ? tablePaginationProps.sx(theme) : tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.sx) }));
};
var MRT_ToolbarAlertBanner = ({ stackAlertBanner, table }) => {
  var _a, _b;
  const { getPrePaginationRowModel, getSelectedRowModel, getState, options: { localization, muiToolbarAlertBannerProps, muiToolbarAlertBannerChipProps, positionToolbarAlertBanner, rowCount } } = table;
  const { grouping, showAlertBanner } = getState();
  const alertProps = muiToolbarAlertBannerProps instanceof Function ? muiToolbarAlertBannerProps({ table }) : muiToolbarAlertBannerProps;
  const chipProps = muiToolbarAlertBannerChipProps instanceof Function ? muiToolbarAlertBannerChipProps({ table }) : muiToolbarAlertBannerChipProps;
  const selectMessage = getSelectedRowModel().rows.length > 0 ? (_b = (_a = localization.selectedCountOfRowCountRowsSelected) === null || _a === void 0 ? void 0 : _a.replace("{selectedCount}", getSelectedRowModel().rows.length.toString())) === null || _b === void 0 ? void 0 : _b.replace("{rowCount}", (rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length).toString()) : null;
  const groupedByMessage = grouping.length > 0 ? import_react2.default.createElement(
    "span",
    null,
    localization.groupedBy,
    " ",
    grouping.map((columnId, index) => import_react2.default.createElement(
      import_react2.Fragment,
      { key: `${index}-${columnId}` },
      index > 0 ? localization.thenBy : "",
      import_react2.default.createElement(Chip_default, Object.assign({ label: table.getColumn(columnId).columnDef.header, onDelete: () => table.getColumn(columnId).toggleGrouping() }, chipProps))
    ))
  ) : null;
  return import_react2.default.createElement(
    Collapse_default,
    { in: showAlertBanner || !!selectMessage || !!groupedByMessage, timeout: stackAlertBanner ? 200 : 0 },
    import_react2.default.createElement(
      Alert_default,
      Object.assign({ color: "info", icon: false }, alertProps, { sx: (theme) => Object.assign({ borderRadius: 0, fontSize: "1rem", left: 0, p: 0, position: "relative", mb: stackAlertBanner ? 0 : positionToolbarAlertBanner === "bottom" ? "-1rem" : void 0, right: 0, top: 0, width: "100%", zIndex: 2 }, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx) instanceof Function ? alertProps.sx(theme) : alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx) }),
      (alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && import_react2.default.createElement(AlertTitle_default, null, alertProps.title),
      import_react2.default.createElement(
        Box_default,
        { sx: { p: "0.5rem 1rem" } },
        alertProps === null || alertProps === void 0 ? void 0 : alertProps.children,
        (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectMessage || groupedByMessage) && import_react2.default.createElement("br", null),
        selectMessage,
        selectMessage && groupedByMessage && import_react2.default.createElement("br", null),
        groupedByMessage
      )
    )
  );
};
var MRT_FullScreenToggleButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FullscreenExitIcon: FullscreenExitIcon2, FullscreenIcon: FullscreenIcon2 }, localization }, setIsFullScreen } = table;
  const { isFullScreen } = getState();
  const handleToggleFullScreen = () => {
    setIsFullScreen(!isFullScreen);
  };
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen },
    import_react2.default.createElement(IconButton_default, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleFullScreen }, rest, { title: void 0 }), isFullScreen ? import_react2.default.createElement(FullscreenExitIcon2, null) : import_react2.default.createElement(FullscreenIcon2, null))
  );
};
var MRT_ShowHideColumnsButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { options: { icons: { ViewColumnIcon: ViewColumnIcon2 }, localization } } = table;
  const [anchorEl, setAnchorEl] = (0, import_react2.useState)(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns },
      import_react2.default.createElement(
        IconButton_default,
        Object.assign({ "aria-label": localization.showHideColumns, onClick: handleClick }, rest, { title: void 0 }),
        import_react2.default.createElement(ViewColumnIcon2, null)
      )
    ),
    import_react2.default.createElement(MRT_ShowHideColumnsMenu, { anchorEl, setAnchorEl, table })
  );
};
var MRT_ToggleDensePaddingButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { DensityLargeIcon: DensityLargeIcon2, DensityMediumIcon: DensityMediumIcon2, DensitySmallIcon: DensitySmallIcon2 }, localization }, setDensity } = table;
  const { density } = getState();
  const handleToggleDensePadding = () => {
    const nextDensity = density === "comfortable" ? "compact" : density === "compact" ? "spacious" : "comfortable";
    setDensity(nextDensity);
  };
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity },
    import_react2.default.createElement(IconButton_default, Object.assign({ "aria-label": localization.toggleDensity, onClick: handleToggleDensePadding }, rest, { title: void 0 }), density === "compact" ? import_react2.default.createElement(DensitySmallIcon2, null) : density === "comfortable" ? import_react2.default.createElement(DensityMediumIcon2, null) : import_react2.default.createElement(DensityLargeIcon2, null))
  );
};
var MRT_ToggleFiltersButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2 }, localization }, setShowFilters } = table;
  const { showColumnFilters } = getState();
  const handleToggleShowFilters = () => {
    setShowFilters(!showColumnFilters);
  };
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters },
    import_react2.default.createElement(IconButton_default, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleShowFilters }, rest, { title: void 0 }), showColumnFilters ? import_react2.default.createElement(FilterListOffIcon2, null) : import_react2.default.createElement(FilterListIcon2, null))
  );
};
var MRT_ToggleGlobalFilterButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { SearchIcon: SearchIcon2, SearchOffIcon: SearchOffIcon2 }, localization }, refs: { searchInputRef }, setShowGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const handleToggleSearch = () => {
    setShowGlobalFilter(!showGlobalFilter);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = searchInputRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  };
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch },
    import_react2.default.createElement(IconButton_default, Object.assign({ disabled: !!globalFilter, onClick: handleToggleSearch }, rest, { title: void 0 }), showGlobalFilter ? import_react2.default.createElement(SearchOffIcon2, null) : import_react2.default.createElement(SearchIcon2, null))
  );
};
var MRT_ToolbarInternalButtons = ({ table }) => {
  var _a;
  const { options: { enableColumnFilters, enableColumnOrdering, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, enablePinning, initialState, renderToolbarInternalActions } } = table;
  return import_react2.default.createElement(Box_default, { sx: {
    alignItems: "center",
    display: "flex",
    zIndex: 3
  } }, (_a = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({
    table
  })) !== null && _a !== void 0 ? _a : import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    enableFilters && enableGlobalFilter && !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && import_react2.default.createElement(MRT_ToggleGlobalFilterButton, { table }),
    enableFilters && enableColumnFilters && import_react2.default.createElement(MRT_ToggleFiltersButton, { table }),
    (enableHiding || enableColumnOrdering || enablePinning) && import_react2.default.createElement(MRT_ShowHideColumnsButton, { table }),
    enableDensityToggle && import_react2.default.createElement(MRT_ToggleDensePaddingButton, { table }),
    enableFullScreenToggle && import_react2.default.createElement(MRT_FullScreenToggleButton, { table })
  ));
};
var MRT_ToolbarDropZone = ({ table }) => {
  var _a, _b;
  const { getState, options: { enableGrouping, localization }, setHoveredColumn } = table;
  const { draggingColumn, hoveredColumn, grouping } = getState();
  const handleDragEnter = (_event) => {
    setHoveredColumn({ id: "drop-zone" });
  };
  return import_react2.default.createElement(
    Fade_default,
    { unmountOnExit: true, mountOnEnter: true, in: !!enableGrouping && !!draggingColumn && !grouping.includes(draggingColumn.id) },
    import_react2.default.createElement(
      Box_default,
      { sx: (theme) => ({
        alignItems: "center",
        backgroundColor: alpha(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone" ? 0.2 : 0.1),
        border: `dashed ${theme.palette.info.main} 2px`,
        display: "flex",
        justifyContent: "center",
        height: "calc(100% - 4px)",
        position: "absolute",
        width: "calc(100% - 4px)",
        zIndex: 2
      }), onDragEnter: handleDragEnter },
      import_react2.default.createElement(Typography_default, null, localization.dropToGroupBy.replace("{column}", (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : ""))
    )
  );
};
var commonToolbarStyles = ({ theme }) => ({
  alignItems: "flex-start",
  backgroundColor: lighten(theme.palette.background.default, 0.04),
  backgroundImage: "none",
  display: "grid",
  flexWrap: "wrap-reverse",
  minHeight: "3.5rem",
  overflow: "hidden",
  p: "0 !important",
  transition: "all 150ms ease-in-out",
  zIndex: 1
});
var MRT_TopToolbar = ({ table }) => {
  var _a;
  const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, muiTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions }, refs: { topToolbarRef } } = table;
  const { isFullScreen, showGlobalFilter } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = muiTopToolbarProps instanceof Function ? muiTopToolbarProps({ table }) : muiTopToolbarProps;
  const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter;
  return import_react2.default.createElement(
    Toolbar_default,
    Object.assign({ variant: "dense" }, toolbarProps, { ref: (ref) => {
      topToolbarRef.current = ref;
      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
        toolbarProps.ref.current = ref;
      }
    }, sx: (theme) => Object.assign(Object.assign({ position: isFullScreen ? "sticky" : void 0, top: isFullScreen ? "0" : void 0 }, commonToolbarStyles({ theme })), (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function ? toolbarProps.sx(theme) : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) }),
    positionToolbarAlertBanner === "top" && import_react2.default.createElement(MRT_ToolbarAlertBanner, { stackAlertBanner, table }),
    ["both", "top"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && import_react2.default.createElement(MRT_ToolbarDropZone, { table }),
    import_react2.default.createElement(
      Box_default,
      { sx: {
        alignItems: "flex-start",
        boxSizing: "border-box",
        display: "flex",
        justifyContent: "space-between",
        p: "0.5rem",
        position: stackAlertBanner ? "relative" : "absolute",
        right: 0,
        top: 0,
        width: "100%"
      } },
      enableGlobalFilter && positionGlobalFilter === "left" && import_react2.default.createElement(MRT_GlobalFilterTextField, { table }),
      (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : import_react2.default.createElement("span", null),
      enableToolbarInternalActions ? import_react2.default.createElement(
        Box_default,
        { sx: {
          display: "flex",
          flexWrap: "wrap-reverse",
          justifyContent: "flex-end"
        } },
        enableGlobalFilter && positionGlobalFilter === "right" && import_react2.default.createElement(MRT_GlobalFilterTextField, { table }),
        import_react2.default.createElement(MRT_ToolbarInternalButtons, { table })
      ) : enableGlobalFilter && positionGlobalFilter === "right" && import_react2.default.createElement(MRT_GlobalFilterTextField, { table })
    ),
    enablePagination && ["top", "both"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && import_react2.default.createElement(MRT_TablePagination, { table, position: "top" }),
    import_react2.default.createElement(MRT_LinearProgressBar, { isTopToolbar: true, table })
  );
};
var MRT_BottomToolbar = ({ table }) => {
  const { getState, options: { enablePagination, muiBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions }, refs: { bottomToolbarRef } } = table;
  const { isFullScreen } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = muiBottomToolbarProps instanceof Function ? muiBottomToolbarProps({ table }) : muiBottomToolbarProps;
  const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
  return import_react2.default.createElement(
    Toolbar_default,
    Object.assign({ variant: "dense" }, toolbarProps, { ref: (ref) => {
      bottomToolbarRef.current = ref;
      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
        toolbarProps.ref.current = ref;
      }
    }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, commonToolbarStyles({ theme })), { bottom: isFullScreen ? "0" : void 0, boxShadow: `0 1px 2px -1px ${alpha(theme.palette.common.black, 0.1)} inset`, left: 0, position: isFullScreen ? "fixed" : "relative", right: 0 }), (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function ? toolbarProps.sx(theme) : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) }),
    import_react2.default.createElement(MRT_LinearProgressBar, { isTopToolbar: false, table }),
    positionToolbarAlertBanner === "bottom" && import_react2.default.createElement(MRT_ToolbarAlertBanner, { stackAlertBanner, table }),
    ["both", "bottom"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && import_react2.default.createElement(MRT_ToolbarDropZone, { table }),
    import_react2.default.createElement(
      Box_default,
      { sx: {
        alignItems: "center",
        boxSizing: "border-box",
        display: "flex",
        justifyContent: "space-between",
        p: "0.5rem",
        width: "100%"
      } },
      renderBottomToolbarCustomActions ? renderBottomToolbarCustomActions({ table }) : import_react2.default.createElement("span", null),
      import_react2.default.createElement(Box_default, { sx: {
        display: "flex",
        justifyContent: "flex-end",
        position: stackAlertBanner ? "relative" : "absolute",
        right: 0,
        top: 0
      } }, enablePagination && ["bottom", "both"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && import_react2.default.createElement(MRT_TablePagination, { table, position: "bottom" }))
    )
  );
};
var MRT_TableHeadCellColumnActionsButton = ({ header, table }) => {
  var _a;
  const { options: { icons: { MoreVertIcon: MoreVertIcon2 }, localization, muiTableHeadCellColumnActionsButtonProps } } = table;
  const { column } = header;
  const { columnDef } = column;
  const [anchorEl, setAnchorEl] = (0, import_react2.useState)(null);
  const handleClick = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const mTableHeadCellColumnActionsButtonProps = muiTableHeadCellColumnActionsButtonProps instanceof Function ? muiTableHeadCellColumnActionsButtonProps({ column, table }) : muiTableHeadCellColumnActionsButtonProps;
  const mcTableHeadCellColumnActionsButtonProps = columnDef.muiTableHeadCellColumnActionsButtonProps instanceof Function ? columnDef.muiTableHeadCellColumnActionsButtonProps({
    column,
    table
  }) : columnDef.muiTableHeadCellColumnActionsButtonProps;
  const iconButtonProps = Object.assign(Object.assign({}, mTableHeadCellColumnActionsButtonProps), mcTableHeadCellColumnActionsButtonProps);
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Tooltip_default,
      { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.columnActions },
      import_react2.default.createElement(
        IconButton_default,
        Object.assign({ "aria-label": localization.columnActions, onClick: handleClick, size: "small" }, iconButtonProps, { sx: (theme) => Object.assign({ height: "2rem", m: "-8px -4px", opacity: 0.5, transform: "scale(0.85)", transition: "opacity 150ms", width: "2rem", "&:hover": {
          opacity: 1
        } }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0 }),
        import_react2.default.createElement(MoreVertIcon2, null)
      )
    ),
    anchorEl && import_react2.default.createElement(MRT_ColumnActionMenu, { anchorEl, header, setAnchorEl, table })
  );
};
var MRT_FilterTextField = ({ header, rangeFilterIndex, table }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { options: { enableColumnFilterModes, columnFilterModeOptions, icons: { FilterListIcon: FilterListIcon2, CloseIcon: CloseIcon2 }, localization, manualFiltering, muiTableHeadCellFilterTextFieldProps }, refs: { filterInputRefs }, setColumnFilterFns } = table;
  const { column } = header;
  const { columnDef } = column;
  const mTableHeadCellFilterTextFieldProps = muiTableHeadCellFilterTextFieldProps instanceof Function ? muiTableHeadCellFilterTextFieldProps({
    column,
    table,
    rangeFilterIndex
  }) : muiTableHeadCellFilterTextFieldProps;
  const mcTableHeadCellFilterTextFieldProps = columnDef.muiTableHeadCellFilterTextFieldProps instanceof Function ? columnDef.muiTableHeadCellFilterTextFieldProps({
    column,
    table,
    rangeFilterIndex
  }) : columnDef.muiTableHeadCellFilterTextFieldProps;
  const textFieldProps = Object.assign(Object.assign({}, mTableHeadCellFilterTextFieldProps), mcTableHeadCellFilterTextFieldProps);
  const isRangeFilter = columnDef.filterVariant === "range" || rangeFilterIndex !== void 0;
  const isSelectFilter = columnDef.filterVariant === "select";
  const isMultiSelectFilter = columnDef.filterVariant === "multi-select";
  const isTextboxFilter = columnDef.filterVariant === "text" || !isSelectFilter && !isMultiSelectFilter;
  const currentFilterOption = columnDef._filterFn;
  const filterChipLabel = ["empty", "notEmpty"].includes(currentFilterOption) ? localization[`filter${((_b = (_a = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _a === void 0 ? void 0 : _a.call(currentFilterOption, 0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`] : "";
  const filterPlaceholder = !isRangeFilter ? (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace("{column}", String(columnDef.header)) : rangeFilterIndex === 0 ? localization.min : rangeFilterIndex === 1 ? localization.max : "";
  const allowedColumnFilterOptions = (_d = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _d !== void 0 ? _d : columnFilterModeOptions;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !rangeFilterIndex && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const [anchorEl, setAnchorEl] = (0, import_react2.useState)(null);
  const [filterValue, setFilterValue] = (0, import_react2.useState)(() => {
    var _a2, _b2;
    return isMultiSelectFilter ? column.getFilterValue() || [] : isRangeFilter ? ((_a2 = column.getFilterValue()) === null || _a2 === void 0 ? void 0 : _a2[rangeFilterIndex]) || [] : (_b2 = column.getFilterValue()) !== null && _b2 !== void 0 ? _b2 : "";
  });
  const handleChangeDebounced = (0, import_react2.useCallback)((0, import_debounce.default)((event) => {
    const value = textFieldProps.type === "date" ? event.target.valueAsDate : textFieldProps.type === "number" ? event.target.valueAsNumber : event.target.value;
    if (isRangeFilter) {
      column.setFilterValue((old) => {
        const newFilterValues = old !== null && old !== void 0 ? old : ["", ""];
        newFilterValues[rangeFilterIndex] = value;
        return newFilterValues;
      });
    } else {
      column.setFilterValue(value !== null && value !== void 0 ? value : void 0);
    }
  }, isTextboxFilter ? manualFiltering ? 400 : 200 : 1), []);
  const handleChange = (event) => {
    setFilterValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleClear = () => {
    if (isMultiSelectFilter) {
      setFilterValue([]);
      column.setFilterValue([]);
    } else if (isRangeFilter) {
      setFilterValue("");
      column.setFilterValue((old) => {
        const newFilterValues = old !== null && old !== void 0 ? old : ["", ""];
        newFilterValues[rangeFilterIndex] = void 0;
        return newFilterValues;
      });
    } else {
      setFilterValue("");
      column.setFilterValue(void 0);
    }
  };
  const handleClearEmptyFilterChip = () => {
    setFilterValue("");
    column.setFilterValue(void 0);
    setColumnFilterFns((prev) => Object.assign(Object.assign({}, prev), { [header.id]: "fuzzy" }));
  };
  const handleFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const isMounted = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    if (isMounted.current && column.getFilterValue() === void 0) {
      handleClear();
    }
    isMounted.current = true;
  }, [column.getFilterValue()]);
  if (columnDef.Filter) {
    return import_react2.default.createElement(import_react2.default.Fragment, null, (_e = columnDef.Filter) === null || _e === void 0 ? void 0 : _e.call(columnDef, { column, header, rangeFilterIndex, table }));
  }
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      TextField_default,
      Object.assign({ fullWidth: true, inputProps: {
        disabled: !!filterChipLabel,
        sx: {
          textOverflow: "ellipsis",
          width: filterChipLabel ? 0 : void 0
        },
        title: filterPlaceholder
      }, helperText: showChangeModeButton ? import_react2.default.createElement("label", null, localization.filterMode.replace(
        "{filterType}",
        localization[`filter${((_f = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _f === void 0 ? void 0 : _f.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
      )) : null, FormHelperTextProps: {
        sx: {
          fontSize: "0.75rem",
          lineHeight: "0.8rem",
          whiteSpace: "nowrap"
        }
      }, margin: "none", placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter ? void 0 : filterPlaceholder, onChange: handleChange, onClick: (e) => e.stopPropagation(), select: isSelectFilter || isMultiSelectFilter, value: filterValue, variant: "standard", InputProps: {
        startAdornment: showChangeModeButton ? import_react2.default.createElement(
          InputAdornment_default,
          { position: "start" },
          import_react2.default.createElement(
            Tooltip_default,
            { arrow: true, title: localization.changeFilterMode },
            import_react2.default.createElement(
              "span",
              null,
              import_react2.default.createElement(
                IconButton_default,
                { "aria-label": localization.changeFilterMode, onClick: handleFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" } },
                import_react2.default.createElement(FilterListIcon2, null)
              )
            )
          ),
          filterChipLabel && import_react2.default.createElement(Chip_default, { onDelete: handleClearEmptyFilterChip, label: filterChipLabel })
        ) : null,
        endAdornment: !filterChipLabel && import_react2.default.createElement(
          InputAdornment_default,
          { position: "end" },
          import_react2.default.createElement(
            Tooltip_default,
            { arrow: true, placement: "right", title: (_g = localization.clearFilter) !== null && _g !== void 0 ? _g : "" },
            import_react2.default.createElement(
              "span",
              null,
              import_react2.default.createElement(
                IconButton_default,
                { "aria-label": localization.clearFilter, disabled: !(filterValue === null || filterValue === void 0 ? void 0 : filterValue.length), onClick: handleClear, size: "small", sx: {
                  height: "1.75rem",
                  width: "1.75rem"
                } },
                import_react2.default.createElement(CloseIcon2, null)
              )
            )
          )
        )
      }, SelectProps: {
        displayEmpty: true,
        multiple: isMultiSelectFilter,
        renderValue: isMultiSelectFilter ? (selected) => !(selected === null || selected === void 0 ? void 0 : selected.length) ? import_react2.default.createElement(Box_default, { sx: { opacity: 0.5 } }, filterPlaceholder) : import_react2.default.createElement(Box_default, { sx: { display: "flex", flexWrap: "wrap", gap: "2px" } }, selected === null || selected === void 0 ? void 0 : selected.map((value) => {
          var _a2;
          const selectedValue = (_a2 = columnDef.filterSelectOptions) === null || _a2 === void 0 ? void 0 : _a2.find((option) => option instanceof Object ? option.value === value : option === value);
          return import_react2.default.createElement(Chip_default, { key: value, label: selectedValue instanceof Object ? selectedValue.text : selectedValue });
        })) : void 0
      } }, textFieldProps, { inputRef: (inputRef) => {
        filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] = inputRef;
        if (textFieldProps.inputRef) {
          textFieldProps.inputRef = inputRef;
        }
      }, sx: (theme) => Object.assign({ p: 0, minWidth: isRangeFilter ? "100px" : !filterChipLabel ? "120px" : "auto", width: "calc(100% + 4px)", mx: "-2px", "& .MuiSelect-icon": {
        mr: "1.5rem"
      } }, (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx) instanceof Function ? textFieldProps.sx(theme) : textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx) }),
      (isSelectFilter || isMultiSelectFilter) && import_react2.default.createElement(
        MenuItem_default,
        { divider: true, disabled: true, hidden: true, value: "" },
        import_react2.default.createElement(Box_default, { sx: { opacity: 0.5 } }, filterPlaceholder)
      ),
      (_h = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterSelectOptions) === null || _h === void 0 ? void 0 : _h.map((option) => {
        var _a2;
        let value;
        let text2;
        if (typeof option !== "object") {
          value = option;
          text2 = option;
        } else {
          value = option.value;
          text2 = option.text;
        }
        return import_react2.default.createElement(
          MenuItem_default,
          { key: value, sx: {
            display: "flex",
            m: 0,
            alignItems: "center",
            gap: "0.5rem"
          }, value },
          isMultiSelectFilter && import_react2.default.createElement(Checkbox_default, { checked: ((_a2 = column.getFilterValue()) !== null && _a2 !== void 0 ? _a2 : []).includes(value), sx: { mr: "0.5rem" } }),
          text2
        );
      })
    ),
    import_react2.default.createElement(MRT_FilterOptionMenu, { anchorEl, header, setAnchorEl, table, setFilterValue })
  );
};
var MRT_FilterRangeFields = ({ header, table }) => {
  return import_react2.default.createElement(
    Box_default,
    { sx: { display: "grid", gridTemplateColumns: "6fr 6fr", gap: "1rem" } },
    import_react2.default.createElement(MRT_FilterTextField, { header, rangeFilterIndex: 0, table }),
    import_react2.default.createElement(MRT_FilterTextField, { header, rangeFilterIndex: 1, table })
  );
};
var MRT_FilterCheckbox = ({ column, table }) => {
  var _a, _b, _c;
  const { getState, options: { localization, muiTableHeadCellFilterCheckboxProps } } = table;
  const { density } = getState();
  const { columnDef } = column;
  const mTableHeadCellFilterCheckboxProps = muiTableHeadCellFilterCheckboxProps instanceof Function ? muiTableHeadCellFilterCheckboxProps({
    column,
    table
  }) : muiTableHeadCellFilterCheckboxProps;
  const mcTableHeadCellFilterCheckboxProps = columnDef.muiTableHeadCellFilterCheckboxProps instanceof Function ? columnDef.muiTableHeadCellFilterCheckboxProps({
    column,
    table
  }) : columnDef.muiTableHeadCellFilterCheckboxProps;
  const checkboxProps = Object.assign(Object.assign({}, mTableHeadCellFilterCheckboxProps), mcTableHeadCellFilterCheckboxProps);
  const filterLabel = (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace("{column}", columnDef.header);
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : filterLabel },
    import_react2.default.createElement(FormControlLabel_default, { control: import_react2.default.createElement(Checkbox_default, Object.assign({ checked: column.getFilterValue() === "true", indeterminate: column.getFilterValue() === void 0, color: column.getFilterValue() === void 0 ? "default" : "primary", size: density === "compact" ? "small" : "medium" }, checkboxProps, { onClick: (e) => {
      var _a2;
      e.stopPropagation();
      (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
    }, onChange: (e, checked) => {
      var _a2;
      column.setFilterValue(column.getFilterValue() === void 0 ? "true" : column.getFilterValue() === "true" ? "false" : void 0);
      (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e, checked);
    }, sx: (theme) => Object.assign({ height: "2.5rem", width: "2.5rem" }, (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function ? checkboxProps.sx(theme) : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) })), disableTypography: true, label: (_c = checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel, sx: { color: "text.secondary", mt: "-4px", fontWeight: "normal" }, title: void 0 })
  );
};
var MRT_TableHeadCellFilterContainer = ({ header, table }) => {
  const { getState } = table;
  const { showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  return import_react2.default.createElement(Collapse_default, { in: showColumnFilters, mountOnEnter: true, unmountOnExit: true }, columnDef.filterVariant === "checkbox" ? import_react2.default.createElement(MRT_FilterCheckbox, { column, table }) : columnDef.filterVariant === "range" || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn) ? import_react2.default.createElement(MRT_FilterRangeFields, { header, table }) : import_react2.default.createElement(MRT_FilterTextField, { header, table }));
};
var MRT_TableHeadCellFilterLabel = ({ header, table }) => {
  var _a, _b, _c;
  const { options: { icons: { FilterAltIcon: FilterAltIcon2 }, localization } } = table;
  const { column } = header;
  const { columnDef } = column;
  const isRangeFilter = columnDef.filterVariant === "range" || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn);
  const currentFilterOption = columnDef._filterFn;
  const filterTooltip = localization.filteringByColumn.replace("{column}", String(columnDef.header)).replace(
    "{filterType}",
    localization[`filter${((_a = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _a === void 0 ? void 0 : _a.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ).replace("{filterValue}", `"${Array.isArray(column.getFilterValue()) ? column.getFilterValue().join(`" ${isRangeFilter ? localization.and : localization.or} "`) : column.getFilterValue()}"`).replace('" "', "");
  return import_react2.default.createElement(
    Grow_default,
    { unmountOnExit: true, in: !!column.getFilterValue() && !isRangeFilter || isRangeFilter && (!!((_b = column.getFilterValue()) === null || _b === void 0 ? void 0 : _b[0]) || !!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[1])) },
    import_react2.default.createElement(
      Box_default,
      { component: "span", sx: { flex: "0 0" } },
      import_react2.default.createElement(
        Tooltip_default,
        { arrow: true, placement: "top", title: filterTooltip },
        import_react2.default.createElement(
          IconButton_default,
          { disableRipple: true, onClick: (event) => {
            event.stopPropagation();
          }, size: "small", sx: {
            height: "12px",
            m: 0,
            opacity: 0.8,
            p: "2px",
            transform: "scale(0.66)",
            width: "12px"
          } },
          import_react2.default.createElement(FilterAltIcon2, null)
        )
      )
    )
  );
};
var MRT_TableHeadCellGrabHandle = ({ column, table, tableHeadCellRef }) => {
  const { getState, options: { enableColumnOrdering, muiTableHeadCellDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn } = table;
  const { columnDef } = column;
  const { hoveredColumn, draggingColumn, columnOrder } = getState();
  const mIconButtonProps = muiTableHeadCellDragHandleProps instanceof Function ? muiTableHeadCellDragHandleProps({ column, table }) : muiTableHeadCellDragHandleProps;
  const mcIconButtonProps = columnDef.muiTableHeadCellDragHandleProps instanceof Function ? columnDef.muiTableHeadCellDragHandleProps({ column, table }) : columnDef.muiTableHeadCellDragHandleProps;
  const iconButtonProps = Object.assign(Object.assign({}, mIconButtonProps), mcIconButtonProps);
  const handleDragStart = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    setDraggingColumn(column);
    event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
  };
  const handleDragEnd = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      column.toggleGrouping();
    } else if (enableColumnOrdering && hoveredColumn && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
    setDraggingColumn(null);
    setHoveredColumn(null);
  };
  return import_react2.default.createElement(MRT_GrabHandleButton, { iconButtonProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table });
};
var MRT_TableHeadCellResizeHandle = ({ header, table }) => {
  var _a;
  const { getState, options: { columnResizeMode } } = table;
  const { density, showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  return import_react2.default.createElement(
    Box_default,
    { onDoubleClick: () => column.resetSize(), onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), sx: (theme) => ({
      cursor: "col-resize",
      mr: density === "compact" ? "-0.5rem" : "-1rem",
      position: "absolute",
      right: "1px",
      px: "4px",
      "&:active > hr": {
        backgroundColor: theme.palette.info.main,
        opacity: 1
      }
    }), style: {
      transform: column.getIsResizing() ? `translateX(${((_a = getState().columnSizingInfo.deltaOffset) !== null && _a !== void 0 ? _a : 0) / (columnResizeMode === "onChange" ? 16 : 1)}px)` : void 0
    } },
    import_react2.default.createElement(Divider_default, { flexItem: true, orientation: "vertical", sx: {
      borderRadius: "2px",
      borderWidth: "2px",
      height: showColumnFilters && columnDefType === "data" ? "3.5rem" : "1.5rem",
      touchAction: "none",
      transition: column.getIsResizing() ? void 0 : "all 150ms ease-in-out",
      userSelect: "none",
      zIndex: 4
    } })
  );
};
var MRT_TableHeadCellSortLabel = ({ header, table, tableCellProps }) => {
  const { options: { icons: { ArrowDownwardIcon: ArrowDownwardIcon2 }, localization } } = table;
  const { column } = header;
  const { columnDef } = column;
  const sortTooltip = column.getIsSorted() ? column.getIsSorted() === "desc" ? localization.sortedByColumnDesc.replace("{column}", columnDef.header) : localization.sortedByColumnAsc.replace("{column}", columnDef.header) : localization.unsorted;
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, placement: "top", title: sortTooltip },
    import_react2.default.createElement(TableSortLabel_default, { "aria-label": sortTooltip, active: !!column.getIsSorted(), direction: column.getIsSorted() ? column.getIsSorted() : void 0, sx: {
      flex: "0 0",
      width: "2.3ch",
      transform: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) !== "right" ? "translateX(-0.5ch)" : void 0
    }, IconComponent: ArrowDownwardIcon2 })
  );
};
var MRT_TableHeadCell = ({ header, table }) => {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const { getState, options: { enableColumnActions, enableColumnDragging, enableColumnOrdering, enableGrouping, enableMultiSort, muiTableHeadCellProps }, refs: { tableHeadCellRefs }, setHoveredColumn } = table;
  const { density, draggingColumn, grouping, hoveredColumn, showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableHeadCellProps = muiTableHeadCellProps instanceof Function ? muiTableHeadCellProps({ column, table }) : muiTableHeadCellProps;
  const mcTableHeadCellProps = columnDef.muiTableHeadCellProps instanceof Function ? columnDef.muiTableHeadCellProps({ column, table }) : columnDef.muiTableHeadCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableHeadCellProps), mcTableHeadCellProps);
  const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) && columnDef.enableColumnActions !== false;
  const showDragHandle = enableColumnDragging !== false && columnDef.enableColumnDragging !== false && (enableColumnDragging || enableColumnOrdering && columnDef.enableColumnOrdering !== false || enableGrouping && columnDef.enableGrouping !== false && !grouping.includes(column.id));
  const headerPL = (0, import_react2.useMemo)(() => {
    let pl = 0;
    if (column.getCanSort())
      pl++;
    if (showColumnActions)
      pl += 1.75;
    if (showDragHandle)
      pl += 1.25;
    return pl;
  }, [showColumnActions, showDragHandle]);
  const draggingBorder = (0, import_react2.useMemo)(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? `1px dashed ${theme.palette.text.secondary}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${theme.palette.primary.main}` : void 0, [draggingColumn, hoveredColumn]);
  const draggingBorders = draggingBorder ? {
    borderLeft: draggingBorder,
    borderRight: draggingBorder,
    borderTop: draggingBorder
  } : void 0;
  const handleDragEnter = (_e) => {
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn && columnDefType !== "group") {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function ? (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
    column,
    header,
    table
  }) : (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _b !== void 0 ? _b : columnDef.header;
  return import_react2.default.createElement(
    TableCell_default,
    Object.assign({ align: columnDefType === "group" ? "center" : "left", colSpan: header.colSpan, onDragEnter: handleDragEnter, ref: (node) => {
      if (node) {
        tableHeadCellRefs.current[column.id] = node;
      }
    } }, tableCellProps, { sx: (theme2) => Object.assign(Object.assign({ fontWeight: "bold", overflow: "visible", p: density === "compact" ? "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pb: columnDefType === "display" ? 0 : showColumnFilters || density === "compact" ? "0.4rem" : "0.6rem", pt: columnDefType === "group" || density === "compact" ? "0.25rem" : density === "comfortable" ? ".75rem" : "1.25rem", userSelect: enableMultiSort && column.getCanSort() ? "none" : void 0, verticalAlign: "top", zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 3 : column.getIsPinned() && columnDefType !== "group" ? 2 : 1 }, getCommonCellStyles({
      column,
      header,
      table,
      tableCellProps,
      theme: theme2
    })), draggingBorders) }),
    header.isPlaceholder ? null : import_react2.default.createElement(
      Box_default,
      { className: "Mui-TableHeadCell-Content", sx: {
        alignItems: "flex-start",
        display: "flex",
        flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
        justifyContent: columnDefType === "group" || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? "center" : column.getCanResize() ? "space-between" : "flex-start",
        position: "relative",
        width: "100%"
      } },
      import_react2.default.createElement(
        Box_default,
        { className: "Mui-TableHeadCell-Content-Labels", onClick: column.getToggleSortingHandler(), sx: {
          alignItems: "center",
          cursor: column.getCanSort() && columnDefType !== "group" ? "pointer" : void 0,
          display: "flex",
          flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
          overflow: columnDefType === "data" ? "hidden" : void 0,
          pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? `${headerPL}rem` : void 0
        } },
        import_react2.default.createElement(Box_default, { className: "Mui-TableHeadCell-Content-Wrapper", sx: {
          overflow: columnDefType === "data" ? "hidden" : void 0,
          textOverflow: "ellipsis",
          whiteSpace: ((_d = (_c = columnDef.header) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < 20 ? "nowrap" : "normal"
        }, title: columnDefType === "data" ? columnDef.header : void 0 }, headerElement),
        column.getCanSort() && import_react2.default.createElement(MRT_TableHeadCellSortLabel, { header, table, tableCellProps }),
        column.getCanFilter() && import_react2.default.createElement(MRT_TableHeadCellFilterLabel, { header, table })
      ),
      columnDefType !== "group" && import_react2.default.createElement(
        Box_default,
        { className: "Mui-TableHeadCell-Content-Actions", sx: { whiteSpace: "nowrap" } },
        showDragHandle && import_react2.default.createElement(MRT_TableHeadCellGrabHandle, { column, table, tableHeadCellRef: {
          current: tableHeadCellRefs.current[column.id]
        } }),
        showColumnActions && import_react2.default.createElement(MRT_TableHeadCellColumnActionsButton, { header, table })
      ),
      column.getCanResize() && import_react2.default.createElement(MRT_TableHeadCellResizeHandle, { header, table })
    ),
    column.getCanFilter() && import_react2.default.createElement(MRT_TableHeadCellFilterContainer, { header, table })
  );
};
var MRT_TableHeadRow = ({ headerGroup, table }) => {
  const { options: { muiTableHeadRowProps } } = table;
  const tableRowProps = muiTableHeadRowProps instanceof Function ? muiTableHeadRowProps({ headerGroup, table }) : muiTableHeadRowProps;
  return import_react2.default.createElement(TableRow_default, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ boxShadow: `4px 0 8px ${alpha(theme.palette.common.black, 0.1)}`, backgroundColor: lighten(theme.palette.background.default, 0.04) }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) }), headerGroup.headers.map((header, index) => import_react2.default.createElement(MRT_TableHeadCell, { header, key: header.id || index, table })));
};
var MRT_TableHead = ({ table }) => {
  const { getHeaderGroups, getState, options: { enableStickyHeader, muiTableHeadProps, enableRowVirtualization } } = table;
  const { isFullScreen } = getState();
  const tableHeadProps = muiTableHeadProps instanceof Function ? muiTableHeadProps({ table }) : muiTableHeadProps;
  const stickyHeader = enableStickyHeader || enableRowVirtualization || isFullScreen;
  return import_react2.default.createElement(TableHead_default, Object.assign({}, tableHeadProps, { sx: (theme) => Object.assign({ opacity: 0.97, position: stickyHeader ? "sticky" : void 0, zIndex: stickyHeader ? 2 : void 0 }, (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx) instanceof Function ? tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx(theme) : tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx) }), getHeaderGroups().map((headerGroup) => import_react2.default.createElement(MRT_TableHeadRow, { headerGroup, key: headerGroup.id, table })));
};
var MRT_EditCellTextField = ({ cell, showLabel, table }) => {
  var _a;
  const { getState, options: { muiTableBodyCellEditTextFieldProps }, refs: { editInputRefs }, setEditingCell, setEditingRow } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const { editingRow } = getState();
  const [value, setValue] = (0, import_react2.useState)(() => cell.getValue());
  const mTableBodyCellEditTextFieldProps = muiTableBodyCellEditTextFieldProps instanceof Function ? muiTableBodyCellEditTextFieldProps({ cell, column, row, table }) : muiTableBodyCellEditTextFieldProps;
  const mcTableBodyCellEditTextFieldProps = columnDef.muiTableBodyCellEditTextFieldProps instanceof Function ? columnDef.muiTableBodyCellEditTextFieldProps({
    cell,
    column,
    row,
    table
  }) : columnDef.muiTableBodyCellEditTextFieldProps;
  const textFieldProps = Object.assign(Object.assign({}, mTableBodyCellEditTextFieldProps), mcTableBodyCellEditTextFieldProps);
  const saveRow = (newValue) => {
    if (editingRow) {
      setEditingRow(Object.assign(Object.assign({}, editingRow), { _valuesCache: Object.assign(Object.assign({}, editingRow._valuesCache), { [column.id]: newValue }) }));
    }
  };
  const handleChange = (event) => {
    var _a2;
    (_a2 = textFieldProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    setValue(event.target.value);
    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select) {
      saveRow(event.target.value);
    }
  };
  const handleBlur = (event) => {
    var _a2;
    (_a2 = textFieldProps.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    saveRow(value);
    setEditingCell(null);
  };
  const handleEnterKeyDown = (event) => {
    var _a2, _b;
    (_a2 = textFieldProps.onKeyDown) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    if (event.key === "Enter") {
      (_b = editInputRefs.current[column.id]) === null || _b === void 0 ? void 0 : _b.blur();
    }
  };
  if (columnDef.Edit) {
    return import_react2.default.createElement(import_react2.default.Fragment, null, (_a = columnDef.Edit) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table }));
  }
  return import_react2.default.createElement(TextField_default, Object.assign({ disabled: columnDef.enableEditing === false, fullWidth: true, inputRef: (inputRef) => {
    if (inputRef) {
      editInputRefs.current[column.id] = inputRef;
      if (textFieldProps.inputRef) {
        textFieldProps.inputRef = inputRef;
      }
    }
  }, label: showLabel ? column.columnDef.header : void 0, margin: "none", name: column.id, placeholder: columnDef.header, value, variant: "standard" }, textFieldProps, { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, e);
  }, onBlur: handleBlur, onChange: handleChange, onKeyDown: handleEnterKeyDown }));
};
var MRT_CopyButton = ({ cell, children, table }) => {
  var _a;
  const { options: { localization, muiTableBodyCellCopyButtonProps } } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const [copied, setCopied] = (0, import_react2.useState)(false);
  const handleCopy = (event, text2) => {
    event.stopPropagation();
    navigator.clipboard.writeText(text2);
    setCopied(true);
    setTimeout(() => setCopied(false), 4e3);
  };
  const mTableBodyCellCopyButtonProps = muiTableBodyCellCopyButtonProps instanceof Function ? muiTableBodyCellCopyButtonProps({ cell, column, row, table }) : muiTableBodyCellCopyButtonProps;
  const mcTableBodyCellCopyButtonProps = columnDef.muiTableBodyCellCopyButtonProps instanceof Function ? columnDef.muiTableBodyCellCopyButtonProps({
    cell,
    column,
    row,
    table
  }) : columnDef.muiTableBodyCellCopyButtonProps;
  const buttonProps = Object.assign(Object.assign({}, mTableBodyCellCopyButtonProps), mcTableBodyCellCopyButtonProps);
  return import_react2.default.createElement(
    Tooltip_default,
    { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : copied ? localization.copiedToClipboard : localization.clickToCopy },
    import_react2.default.createElement(Button_default, Object.assign({ onClick: (e) => handleCopy(e, cell.getValue()), size: "small", type: "button", variant: "text" }, buttonProps, { sx: (theme) => Object.assign({ backgroundColor: "transparent", border: "none", color: "inherit", cursor: "copy", fontFamily: "inherit", fontSize: "inherit", letterSpacing: "inherit", m: "-0.25rem", minWidth: "unset", textAlign: "inherit", textTransform: "inherit" }, (buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx) instanceof Function ? buttonProps.sx(theme) : buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx), title: void 0 }), children)
  );
};
var MRT_TableBodyRowGrabHandle = ({ cell, rowRef, table }) => {
  const { options: { muiTableBodyRowDragHandleProps } } = table;
  const { row } = cell;
  const iconButtonProps = muiTableBodyRowDragHandleProps instanceof Function ? muiTableBodyRowDragHandleProps({ row, table }) : muiTableBodyRowDragHandleProps;
  const handleDragStart = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    event.dataTransfer.setDragImage(rowRef.current, 0, 0);
    table.setDraggingRow(row);
  };
  const handleDragEnd = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    table.setDraggingRow(null);
    table.setHoveredRow(null);
  };
  return import_react2.default.createElement(MRT_GrabHandleButton, { iconButtonProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table });
};
var MRT_TableBodyCellValue = ({ cell, table }) => {
  var _a, _b;
  const { column, row } = cell;
  const { columnDef } = column;
  return import_react2.default.createElement(import_react2.default.Fragment, null, cell.getIsAggregated() && columnDef.AggregatedCell ? columnDef.AggregatedCell({
    cell,
    column,
    row,
    table
  }) : row.getIsGrouped() && !cell.getIsGrouped() ? null : cell.getIsGrouped() && columnDef.GroupedCell ? columnDef.GroupedCell({
    cell,
    column,
    row,
    table
  }) : (_b = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Cell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table })) !== null && _b !== void 0 ? _b : cell.renderValue());
};
var MRT_TableBodyCell = ({ cell, enableHover, numRows, rowIndex, rowRef, table }) => {
  var _a, _b;
  const theme = useTheme();
  const { getState, options: { editingMode, enableClickToCopy, enableColumnOrdering, enableEditing, enableGrouping, enableRowNumbers, muiTableBodyCellProps, muiTableBodyCellSkeletonProps, rowNumberMode }, refs: { editInputRefs }, setEditingCell, setHoveredColumn } = table;
  const { draggingColumn, editingCell, editingRow, hoveredColumn, density, isLoading, showSkeletons } = getState();
  const { column, row } = cell;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableCellBodyProps = muiTableBodyCellProps instanceof Function ? muiTableBodyCellProps({ cell, column, row, table }) : muiTableBodyCellProps;
  const mcTableCellBodyProps = columnDef.muiTableBodyCellProps instanceof Function ? columnDef.muiTableBodyCellProps({ cell, column, row, table }) : columnDef.muiTableBodyCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableCellBodyProps), mcTableCellBodyProps);
  const skeletonProps = muiTableBodyCellSkeletonProps instanceof Function ? muiTableBodyCellSkeletonProps({ cell, column, row, table }) : muiTableBodyCellSkeletonProps;
  const [skeletonWidth, setSkeletonWidth] = (0, import_react2.useState)(0);
  (0, import_react2.useEffect)(() => setSkeletonWidth(isLoading || showSkeletons ? columnDefType === "display" ? column.getSize() / 2 : Math.round(Math.random() * (column.getSize() - column.getSize() / 3) + column.getSize() / 3) : 100), []);
  const draggingBorder = (0, import_react2.useMemo)(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? `1px dashed ${theme.palette.text.secondary}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${theme.palette.primary.main}` : void 0, [draggingColumn, hoveredColumn]);
  const draggingBorders = (0, import_react2.useMemo)(() => draggingBorder ? {
    borderLeft: draggingBorder,
    borderRight: draggingBorder,
    borderBottom: rowIndex === numRows - 1 ? draggingBorder : void 0
  } : void 0, [draggingBorder, numRows]);
  const isEditable = (enableEditing || columnDef.enableEditing) && columnDef.enableEditing !== false;
  const isEditing = isEditable && editingMode !== "modal" && (editingMode === "table" || (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id || (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) && !row.getIsGrouped();
  const handleDoubleClick = (event) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, event);
    if ((enableEditing || columnDef.enableEditing) && columnDef.enableEditing !== false && editingMode === "cell") {
      setEditingCell(cell);
      queueMicrotask(() => {
        var _a3;
        const textField = editInputRefs.current[column.id];
        if (textField) {
          textField.focus();
          (_a3 = textField.select) === null || _a3 === void 0 ? void 0 : _a3.call(textField);
        }
      });
    }
  };
  const handleDragEnter = (e) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, e);
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn) {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  return import_react2.default.createElement(
    TableCell_default,
    Object.assign({}, tableCellProps, { onDragEnter: handleDragEnter, onDoubleClick: handleDoubleClick, sx: (theme2) => Object.assign(Object.assign({ cursor: isEditable && editingMode === "cell" ? "pointer" : "inherit", overflow: "hidden", p: density === "compact" ? columnDefType === "display" ? "0 0.5rem" : "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.5rem 0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pl: column.id === "mrt-row-expand" ? `${row.depth + (density === "compact" ? 0.5 : density === "comfortable" ? 0.75 : 1.25)}rem` : void 0, textOverflow: columnDefType !== "display" ? "ellipsis" : void 0, whiteSpace: density === "compact" ? "nowrap" : "normal", zIndex: (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : column.getIsPinned() ? 1 : 0, "&:hover": {
      backgroundColor: enableHover && enableEditing && columnDef.enableEditing !== false && ["table", "cell"].includes(editingMode !== null && editingMode !== void 0 ? editingMode : "") ? theme2.palette.mode === "dark" ? `${lighten(theme2.palette.background.default, 0.2)} !important` : `${darken(theme2.palette.background.default, 0.1)} !important` : void 0
    } }, getCommonCellStyles({ column, table, theme: theme2, tableCellProps })), draggingBorders) }),
    import_react2.default.createElement(import_react2.default.Fragment, null, cell.getIsPlaceholder() ? null : isLoading || showSkeletons ? import_react2.default.createElement(Skeleton_default, Object.assign({ animation: "wave", height: 20, width: skeletonWidth }, skeletonProps)) : enableRowNumbers && rowNumberMode === "static" && column.id === "mrt-row-numbers" ? rowIndex + 1 : column.id === "mrt-row-drag" ? import_react2.default.createElement(MRT_TableBodyRowGrabHandle, { cell, rowRef, table }) : columnDefType === "display" && (column.id === "mrt-row-select" || column.id === "mrt-row-expand" || !row.getIsGrouped()) ? (_a = columnDef.Cell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table }) : isEditing ? import_react2.default.createElement(MRT_EditCellTextField, { cell, table }) : (enableClickToCopy || columnDef.enableClickToCopy) && columnDef.enableClickToCopy !== false ? import_react2.default.createElement(
      MRT_CopyButton,
      { cell, table },
      import_react2.default.createElement(MRT_TableBodyCellValue, { cell, table })
    ) : import_react2.default.createElement(MRT_TableBodyCellValue, { cell, table })),
    cell.getIsGrouped() && !columnDef.GroupedCell && import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      " (",
      (_b = row.subRows) === null || _b === void 0 ? void 0 : _b.length,
      ")"
    )
  );
};
var Memo_MRT_TableBodyCell = (0, import_react2.memo)(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);
var MRT_TableDetailPanel = ({ row, table }) => {
  const { getVisibleLeafColumns, getState, options: { muiTableBodyRowProps, muiTableDetailPanelProps, renderDetailPanel } } = table;
  const { isLoading } = getState();
  const tableRowProps = muiTableBodyRowProps instanceof Function ? muiTableBodyRowProps({ row, table }) : muiTableBodyRowProps;
  const tableCellProps = muiTableDetailPanelProps instanceof Function ? muiTableDetailPanelProps({ row, table }) : muiTableDetailPanelProps;
  return import_react2.default.createElement(
    TableRow_default,
    Object.assign({}, tableRowProps),
    import_react2.default.createElement(TableCell_default, Object.assign({ colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => Object.assign({ borderBottom: !row.getIsExpanded() ? "none" : void 0, pb: row.getIsExpanded() ? "1rem" : 0, pt: row.getIsExpanded() ? "1rem" : 0, transition: "all 150ms ease-in-out", width: `${table.getTotalSize()}px` }, (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function ? tableCellProps.sx(theme) : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) }), renderDetailPanel && import_react2.default.createElement(Collapse_default, { in: row.getIsExpanded(), mountOnEnter: true, unmountOnExit: true }, !isLoading && renderDetailPanel({ row, table })))
  );
};
var MRT_TableBodyRow = ({ numRows, row, rowIndex, table, virtualRow }) => {
  const theme = useTheme();
  const { getIsSomeColumnsPinned, getState, options: { enableRowOrdering, memoMode, muiTableBodyRowProps, renderDetailPanel }, setHoveredRow } = table;
  const { draggingColumn, draggingRow, editingCell, editingRow, hoveredRow } = getState();
  const tableRowProps = muiTableBodyRowProps instanceof Function ? muiTableBodyRowProps({ row, table }) : muiTableBodyRowProps;
  const handleDragEnter = (_e) => {
    if (enableRowOrdering && draggingRow) {
      setHoveredRow(row);
    }
  };
  const rowRef = (0, import_react2.useRef)(null);
  const draggingBorder = (0, import_react2.useMemo)(() => (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id ? `1px dashed ${theme.palette.text.secondary}` : (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id ? `2px dashed ${theme.palette.primary.main}` : void 0, [draggingRow, hoveredRow]);
  const draggingBorders = draggingBorder ? {
    border: draggingBorder
  } : void 0;
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(TableRow_default, Object.assign({ onDragEnter: handleDragEnter, hover: true, selected: row.getIsSelected(), ref: (node) => {
      rowRef.current = node;
      if (virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.measureRef) {
        virtualRow.measureRef = node;
      }
    } }, tableRowProps, { sx: (theme2) => Object.assign(Object.assign({ backgroundColor: lighten(theme2.palette.background.default, 0.06), opacity: (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id || (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id ? 0.5 : 1, transition: "all 150ms ease-in-out", "&:hover td": {
      backgroundColor: (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false && getIsSomeColumnsPinned() ? theme2.palette.mode === "dark" ? `${lighten(theme2.palette.background.default, 0.12)}` : `${darken(theme2.palette.background.default, 0.05)}` : void 0
    } }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps.sx(theme2) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx), draggingBorders) }), row.getVisibleCells().map((cell) => {
      const props2 = {
        cell,
        enableHover: (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false,
        key: cell.id,
        numRows,
        rowIndex,
        rowRef,
        table
      };
      return memoMode === "cells" && cell.column.columnDef.columnDefType === "data" && !draggingColumn && !draggingRow && (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id && (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? import_react2.default.createElement(Memo_MRT_TableBodyCell, Object.assign({}, props2)) : import_react2.default.createElement(MRT_TableBodyCell, Object.assign({}, props2));
    })),
    renderDetailPanel && !row.getIsGrouped() && import_react2.default.createElement(MRT_TableDetailPanel, { row, table })
  );
};
var Memo_MRT_TableBodyRow = (0, import_react2.memo)(MRT_TableBodyRow, (prev, next) => prev.row === next.row);
var MRT_TableBody = ({ table }) => {
  var _a, _b;
  const { getRowModel, getPrePaginationRowModel, getState, options: { enableGlobalFilterRankedResults, enablePagination, enableRowVirtualization, localization, manualFiltering, manualSorting, memoMode, muiTableBodyProps, virtualizerInstanceRef, virtualizerProps }, refs: { tableContainerRef, tablePaperRef } } = table;
  const { columnFilters, globalFilter, pagination, sorting } = getState();
  const tableBodyProps = muiTableBodyProps instanceof Function ? muiTableBodyProps({ table }) : muiTableBodyProps;
  const vProps = virtualizerProps instanceof Function ? virtualizerProps({ table }) : virtualizerProps;
  const rows = (0, import_react2.useMemo)(() => {
    if (enableGlobalFilterRankedResults && globalFilter && !manualFiltering && !manualSorting && !Object.values(sorting).some(Boolean)) {
      const rankedRows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
      if (enablePagination) {
        const start = pagination.pageIndex * pagination.pageSize;
        return rankedRows.slice(start, start + pagination.pageSize);
      }
      return rankedRows;
    }
    return enablePagination ? getRowModel().rows : getPrePaginationRowModel().rows;
  }, [
    enableGlobalFilterRankedResults,
    enableGlobalFilterRankedResults && globalFilter || !enablePagination ? getPrePaginationRowModel().rows : getRowModel().rows,
    globalFilter,
    pagination.pageIndex,
    pagination.pageSize
  ]);
  const virtualizer = enableRowVirtualization ? useVirtual(Object.assign({ size: rows.length, parentRef: tableContainerRef, overscan: 15 }, vProps)) : {};
  if (virtualizerInstanceRef) {
    virtualizerInstanceRef.current = virtualizer;
  }
  const virtualRows = enableRowVirtualization ? virtualizer.virtualItems : [];
  let paddingTop = 0;
  let paddingBottom = 0;
  if (enableRowVirtualization) {
    paddingTop = virtualRows.length ? virtualRows[0].start : 0;
    paddingBottom = virtualRows.length ? virtualizer.totalSize - virtualRows[virtualRows.length - 1].end : 0;
  }
  return import_react2.default.createElement(TableBody_default, Object.assign({}, tableBodyProps), ((_a = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _a !== void 0 ? _a : !rows.length) ? import_react2.default.createElement(
    "tr",
    null,
    import_react2.default.createElement(
      "td",
      { colSpan: table.getVisibleLeafColumns().length },
      import_react2.default.createElement(Typography_default, { sx: {
        color: "text.secondary",
        fontStyle: "italic",
        maxWidth: `min(100vw, ${(_b = tablePaperRef.current) === null || _b === void 0 ? void 0 : _b.clientWidth}px)`,
        py: "2rem",
        textAlign: "center",
        width: "100%"
      } }, globalFilter || columnFilters.length ? localization.noResultsFound : localization.noRecordsToDisplay)
    )
  ) : import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    enableRowVirtualization && paddingTop > 0 && import_react2.default.createElement(
      "tr",
      null,
      import_react2.default.createElement("td", { style: { height: `${paddingTop}px` } })
    ),
    (enableRowVirtualization ? virtualRows : rows).map((rowOrVirtualRow, rowIndex) => {
      const row = enableRowVirtualization ? rows[rowOrVirtualRow.index] : rowOrVirtualRow;
      const props2 = {
        key: row.id,
        numRows: rows.length,
        row,
        rowIndex: enableRowVirtualization ? rowOrVirtualRow.index : rowIndex,
        table,
        virtualRow: enableRowVirtualization ? rowOrVirtualRow : null
      };
      return memoMode === "rows" ? import_react2.default.createElement(Memo_MRT_TableBodyRow, Object.assign({}, props2)) : import_react2.default.createElement(MRT_TableBodyRow, Object.assign({}, props2));
    }),
    enableRowVirtualization && paddingBottom > 0 && import_react2.default.createElement(
      "tr",
      null,
      import_react2.default.createElement("td", { style: { height: `${paddingBottom}px` } })
    )
  ));
};
var Memo_MRT_TableBody = (0, import_react2.memo)(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);
var MRT_TableFooterCell = ({ footer, table }) => {
  var _a, _b, _c;
  const { getState, options: { muiTableFooterCellProps } } = table;
  const { density } = getState();
  const { column } = footer;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableFooterCellProps = muiTableFooterCellProps instanceof Function ? muiTableFooterCellProps({ column, table }) : muiTableFooterCellProps;
  const mcTableFooterCellProps = columnDef.muiTableFooterCellProps instanceof Function ? columnDef.muiTableFooterCellProps({ column, table }) : columnDef.muiTableFooterCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableFooterCellProps), mcTableFooterCellProps);
  return import_react2.default.createElement(
    TableCell_default,
    Object.assign({ align: columnDefType === "group" ? "center" : "left", colSpan: footer.colSpan, variant: "head" }, tableCellProps, { sx: (theme) => Object.assign({ fontWeight: "bold", p: density === "compact" ? "0.5rem" : density === "comfortable" ? "1rem" : "1.5rem", verticalAlign: "top", zIndex: column.getIsPinned() && columnDefType !== "group" ? 2 : 1 }, getCommonCellStyles({ column, table, theme, tableCellProps })) }),
    import_react2.default.createElement(import_react2.default.Fragment, null, footer.isPlaceholder ? null : (_c = (_b = columnDef.Footer instanceof Function ? (_a = columnDef.Footer) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
      column,
      footer,
      table
    }) : columnDef.Footer) !== null && _b !== void 0 ? _b : columnDef.footer) !== null && _c !== void 0 ? _c : null)
  );
};
var MRT_TableFooterRow = ({ footerGroup, table }) => {
  var _a;
  const { options: { muiTableFooterRowProps } } = table;
  if (!((_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => typeof header.column.columnDef.footer === "string" && !!header.column.columnDef.footer || header.column.columnDef.Footer)))
    return null;
  const tableRowProps = muiTableFooterRowProps instanceof Function ? muiTableFooterRowProps({ footerGroup, table }) : muiTableFooterRowProps;
  return import_react2.default.createElement(TableRow_default, Object.assign({}, tableRowProps), footerGroup.headers.map((footer) => import_react2.default.createElement(MRT_TableFooterCell, { footer, key: footer.id, table })));
};
var MRT_TableFooter = ({ table }) => {
  const { getFooterGroups, getState, options: { enableStickyFooter, muiTableFooterProps } } = table;
  const { isFullScreen } = getState();
  const tableFooterProps = muiTableFooterProps instanceof Function ? muiTableFooterProps({ table }) : muiTableFooterProps;
  const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
  return import_react2.default.createElement(TableFooter_default, Object.assign({}, tableFooterProps, { sx: (theme) => Object.assign({ backgroundColor: lighten(theme.palette.background.default, 0.06), bottom: stickFooter ? 0 : void 0, opacity: stickFooter ? 0.97 : void 0, outline: stickFooter ? theme.palette.mode === "light" ? `1px solid ${theme.palette.grey[300]}` : `1px solid ${theme.palette.grey[700]}` : void 0, position: stickFooter ? "sticky" : void 0 }, (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx) instanceof Function ? tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx(theme) : tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx) }), getFooterGroups().map((footerGroup) => import_react2.default.createElement(MRT_TableFooterRow, { footerGroup, key: footerGroup.id, table })));
};
var MRT_Table = ({ table }) => {
  const { getState, options: { enableColumnResizing, enableRowVirtualization, enableStickyHeader, enableTableFooter, enableTableHead, memoMode, muiTableProps } } = table;
  const { isFullScreen } = getState();
  const tableProps = muiTableProps instanceof Function ? muiTableProps({ table }) : muiTableProps;
  return import_react2.default.createElement(
    Table_default,
    Object.assign({ stickyHeader: enableStickyHeader || enableRowVirtualization || isFullScreen }, tableProps, { sx: (theme) => Object.assign({ tableLayout: enableColumnResizing || enableRowVirtualization ? "fixed" : "auto" }, (tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx) instanceof Function ? tableProps.sx(theme) : tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx) }),
    enableTableHead && import_react2.default.createElement(MRT_TableHead, { table }),
    memoMode === "table-body" ? import_react2.default.createElement(Memo_MRT_TableBody, { table }) : import_react2.default.createElement(MRT_TableBody, { table }),
    enableTableFooter && import_react2.default.createElement(MRT_TableFooter, { table })
  );
};
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
var MRT_TableContainer = ({ table }) => {
  const { getState, options: { enableStickyHeader, enableRowVirtualization, muiTableContainerProps }, refs: { tableContainerRef, bottomToolbarRef, topToolbarRef } } = table;
  const { isFullScreen } = getState();
  const [totalToolbarHeight, setTotalToolbarHeight] = (0, import_react2.useState)(0);
  const tableContainerProps = muiTableContainerProps instanceof Function ? muiTableContainerProps({ table }) : muiTableContainerProps;
  useIsomorphicLayoutEffect2(() => {
    var _a, _b, _c, _d;
    const topToolbarHeight = typeof document !== "undefined" ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0 : 0;
    const bottomToolbarHeight = typeof document !== "undefined" ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0 : 0;
    setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
  });
  return import_react2.default.createElement(
    TableContainer_default,
    Object.assign({}, tableContainerProps, { ref: (ref) => {
      tableContainerRef.current = ref;
      if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
        tableContainerProps.ref.current = ref;
      }
    }, sx: (theme) => Object.assign({ maxWidth: "100%", maxHeight: enableStickyHeader || enableRowVirtualization ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)` : void 0, overflow: "auto" }, (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx) instanceof Function ? tableContainerProps.sx(theme) : tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx), style: Object.assign({ maxHeight: isFullScreen ? `calc(100vh - ${totalToolbarHeight}px)` : void 0 }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style) }),
    import_react2.default.createElement(MRT_Table, { table })
  );
};
var MRT_TablePaper = ({ table }) => {
  const { getState, options: { enableBottomToolbar, enableTopToolbar, muiTablePaperProps, renderBottomToolbar, renderTopToolbar }, refs: { tablePaperRef } } = table;
  const { isFullScreen } = getState();
  const tablePaperProps = muiTablePaperProps instanceof Function ? muiTablePaperProps({ table }) : muiTablePaperProps;
  return import_react2.default.createElement(
    Paper_default,
    Object.assign({ elevation: 2 }, tablePaperProps, { ref: (ref) => {
      tablePaperRef.current = ref;
      if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {
        tablePaperProps.ref.current = ref;
      }
    }, sx: (theme) => Object.assign({ transition: "all 150ms ease-in-out" }, (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx) instanceof Function ? tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx(theme) : tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx), style: Object.assign(Object.assign({}, tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style), isFullScreen ? {
      height: "100vh",
      margin: 0,
      maxHeight: "100vh",
      maxWidth: "100vw",
      padding: 0,
      width: "100vw"
    } : {}) }),
    enableTopToolbar && (renderTopToolbar instanceof Function ? renderTopToolbar({ table }) : renderTopToolbar !== null && renderTopToolbar !== void 0 ? renderTopToolbar : import_react2.default.createElement(MRT_TopToolbar, { table })),
    import_react2.default.createElement(MRT_TableContainer, { table }),
    enableBottomToolbar && (renderBottomToolbar instanceof Function ? renderBottomToolbar({ table }) : renderBottomToolbar !== null && renderBottomToolbar !== void 0 ? renderBottomToolbar : import_react2.default.createElement(MRT_BottomToolbar, { table }))
  );
};
var MRT_EditRowModal = ({ open, row, table }) => {
  const { options: { localization } } = table;
  return import_react2.default.createElement(
    Dialog_default,
    { open },
    import_react2.default.createElement(DialogTitle_default, { textAlign: "center" }, localization.edit),
    import_react2.default.createElement(
      DialogContent_default,
      null,
      import_react2.default.createElement(
        "form",
        { onSubmit: (e) => e.preventDefault() },
        import_react2.default.createElement(Stack_default, { sx: {
          gap: "1.5rem",
          minWidth: { xs: "300px", sm: "360px", md: "400px" },
          pt: "1rem",
          width: "100%"
        } }, row.getAllCells().filter((cell) => cell.column.columnDef.columnDefType === "data").map((cell) => import_react2.default.createElement(MRT_EditCellTextField, { cell, key: cell.id, showLabel: true, table })))
      )
    ),
    import_react2.default.createElement(
      DialogActions_default,
      { sx: { p: "1.25rem" } },
      import_react2.default.createElement(MRT_EditActionButtons, { row, table, variant: "text" })
    )
  );
};
var MRT_TableRoot = (props2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
  const bottomToolbarRef = (0, import_react2.useRef)(null);
  const editInputRefs = (0, import_react2.useRef)({});
  const filterInputRefs = (0, import_react2.useRef)({});
  const searchInputRef = (0, import_react2.useRef)(null);
  const tableContainerRef = (0, import_react2.useRef)(null);
  const tableHeadCellRefs = (0, import_react2.useRef)({});
  const tablePaperRef = (0, import_react2.useRef)(null);
  const topToolbarRef = (0, import_react2.useRef)(null);
  const initialState = (0, import_react2.useMemo)(() => {
    var _a2, _b2, _c2;
    const initState = (_a2 = props2.initialState) !== null && _a2 !== void 0 ? _a2 : {};
    initState.columnOrder = (_b2 = initState.columnOrder) !== null && _b2 !== void 0 ? _b2 : getDefaultColumnOrderIds(props2);
    initState.globalFilterFn = (_c2 = props2.globalFilterFn) !== null && _c2 !== void 0 ? _c2 : "fuzzy";
    return initState;
  }, []);
  const [columnFilterFns, setColumnFilterFns] = (0, import_react2.useState)(() => Object.assign({}, ...getAllLeafColumnDefs(props2.columns).map((col) => {
    var _a2, _b2, _c2, _d2;
    return {
      [getColumnId(col)]: col.filterFn instanceof Function ? (_a2 = col.filterFn.name) !== null && _a2 !== void 0 ? _a2 : "custom" : (_d2 = (_b2 = col.filterFn) !== null && _b2 !== void 0 ? _b2 : (_c2 = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c2 === void 0 ? void 0 : _c2[getColumnId(col)]) !== null && _d2 !== void 0 ? _d2 : getDefaultColumnFilterFn(col)
    };
  })));
  const [columnOrder, setColumnOrder] = (0, import_react2.useState)((_a = initialState.columnOrder) !== null && _a !== void 0 ? _a : []);
  const [density, setDensity] = (0, import_react2.useState)((_b = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _b !== void 0 ? _b : "comfortable");
  const [draggingColumn, setDraggingColumn] = (0, import_react2.useState)((_c = initialState.draggingColumn) !== null && _c !== void 0 ? _c : null);
  const [draggingRow, setDraggingRow] = (0, import_react2.useState)((_d = initialState.draggingRow) !== null && _d !== void 0 ? _d : null);
  const [editingCell, setEditingCell] = (0, import_react2.useState)((_e = initialState.editingCell) !== null && _e !== void 0 ? _e : null);
  const [editingRow, setEditingRow] = (0, import_react2.useState)((_f = initialState.editingRow) !== null && _f !== void 0 ? _f : null);
  const [globalFilterFn, setGlobalFilterFn] = (0, import_react2.useState)((_g = initialState.globalFilterFn) !== null && _g !== void 0 ? _g : "fuzzy");
  const [grouping, setGrouping] = (0, import_react2.useState)((_h = initialState.grouping) !== null && _h !== void 0 ? _h : []);
  const [hoveredColumn, setHoveredColumn] = (0, import_react2.useState)((_j = initialState.hoveredColumn) !== null && _j !== void 0 ? _j : null);
  const [hoveredRow, setHoveredRow] = (0, import_react2.useState)((_k = initialState.hoveredRow) !== null && _k !== void 0 ? _k : null);
  const [isFullScreen, setIsFullScreen] = (0, import_react2.useState)((_l = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _l !== void 0 ? _l : false);
  const [showAlertBanner, setShowAlertBanner] = (0, import_react2.useState)((_o = (_m = props2.initialState) === null || _m === void 0 ? void 0 : _m.showAlertBanner) !== null && _o !== void 0 ? _o : false);
  const [showColumnFilters, setShowFilters] = (0, import_react2.useState)((_p = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _p !== void 0 ? _p : false);
  const [showGlobalFilter, setShowGlobalFilter] = (0, import_react2.useState)((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _q !== void 0 ? _q : false);
  const displayColumns = (0, import_react2.useMemo)(() => {
    var _a2, _b2, _c2, _d2, _e2;
    return [
      columnOrder.includes("mrt-row-drag") && Object.assign(Object.assign(Object.assign({ header: props2.localization.move, size: 60 }, props2.defaultDisplayColumn), (_a2 = props2.displayColumnDefOptions) === null || _a2 === void 0 ? void 0 : _a2["mrt-row-drag"]), { id: "mrt-row-drag" }),
      columnOrder.includes("mrt-row-actions") && Object.assign(Object.assign(Object.assign({ Cell: ({ cell, row }) => import_react2.default.createElement(MRT_ToggleRowActionMenuButton, { cell, row, table }), header: props2.localization.actions, size: 70 }, props2.defaultDisplayColumn), (_b2 = props2.displayColumnDefOptions) === null || _b2 === void 0 ? void 0 : _b2["mrt-row-actions"]), { id: "mrt-row-actions" }),
      columnOrder.includes("mrt-row-expand") && showExpandColumn(props2, grouping) && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => import_react2.default.createElement(MRT_ExpandButton, { row, table }), Header: props2.enableExpandAll ? () => import_react2.default.createElement(MRT_ExpandAllButton, { table }) : null, header: props2.localization.expand, size: 60 }, props2.defaultDisplayColumn), (_c2 = props2.displayColumnDefOptions) === null || _c2 === void 0 ? void 0 : _c2["mrt-row-expand"]), { id: "mrt-row-expand" }),
      columnOrder.includes("mrt-row-select") && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => import_react2.default.createElement(MRT_SelectCheckbox, { row, table }), Header: props2.enableSelectAll && props2.enableMultiRowSelection ? () => import_react2.default.createElement(MRT_SelectCheckbox, { selectAll: true, table }) : null, header: props2.localization.select, size: 60 }, props2.defaultDisplayColumn), (_d2 = props2.displayColumnDefOptions) === null || _d2 === void 0 ? void 0 : _d2["mrt-row-select"]), { id: "mrt-row-select" }),
      columnOrder.includes("mrt-row-numbers") && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => row.index + 1, Header: () => props2.localization.rowNumber, header: props2.localization.rowNumbers, size: 60 }, props2.defaultDisplayColumn), (_e2 = props2.displayColumnDefOptions) === null || _e2 === void 0 ? void 0 : _e2["mrt-row-numbers"]), { id: "mrt-row-numbers" })
    ].filter(Boolean);
  }, [
    columnOrder,
    grouping,
    props2.displayColumnDefOptions,
    props2.editingMode,
    props2.enableColumnDragging,
    props2.enableColumnFilterModes,
    props2.enableColumnOrdering,
    props2.enableEditing,
    props2.enableExpandAll,
    props2.enableExpanding,
    props2.enableGrouping,
    props2.enableRowActions,
    props2.enableRowDragging,
    props2.enableRowNumbers,
    props2.enableRowOrdering,
    props2.enableRowSelection,
    props2.enableSelectAll,
    props2.localization,
    props2.positionActionsColumn,
    props2.renderDetailPanel
  ]);
  const columnDefs = (0, import_react2.useMemo)(() => {
    var _a2, _b2, _c2;
    return prepareColumns({
      aggregationFns: props2.aggregationFns,
      columnDefs: [...displayColumns, ...props2.columns],
      columnFilterFns: (_b2 = (_a2 = props2.state) === null || _a2 === void 0 ? void 0 : _a2.columnFilterFns) !== null && _b2 !== void 0 ? _b2 : columnFilterFns,
      defaultDisplayColumn: (_c2 = props2.defaultDisplayColumn) !== null && _c2 !== void 0 ? _c2 : {},
      filterFns: props2.filterFns,
      sortingFns: props2.sortingFns
    });
  }, [
    columnFilterFns,
    displayColumns,
    props2.columns,
    (_r = props2.state) === null || _r === void 0 ? void 0 : _r.columnFilterFns
  ]);
  const data = (0, import_react2.useMemo)(() => {
    var _a2, _b2, _c2, _d2, _e2;
    return (((_a2 = props2.state) === null || _a2 === void 0 ? void 0 : _a2.isLoading) || ((_b2 = props2.state) === null || _b2 === void 0 ? void 0 : _b2.showSkeletons)) && !props2.data.length ? [
      ...Array(((_d2 = (_c2 = props2.state) === null || _c2 === void 0 ? void 0 : _c2.pagination) === null || _d2 === void 0 ? void 0 : _d2.pageSize) || ((_e2 = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) === null || _e2 === void 0 ? void 0 : _e2.pageSize) || 10).fill(null)
    ].map(() => Object.assign({}, ...getAllLeafColumnDefs(props2.columns).map((col) => {
      var _a3, _b3;
      return {
        [(_b3 = (_a3 = col.id) !== null && _a3 !== void 0 ? _a3 : col.accessorKey) !== null && _b3 !== void 0 ? _b3 : ""]: null
      };
    }))) : props2.data;
  }, [props2.data, (_s = props2.state) === null || _s === void 0 ? void 0 : _s.isLoading, (_t = props2.state) === null || _t === void 0 ? void 0 : _t.showSkeletons]);
  const table = Object.assign(Object.assign({}, useReactTable(Object.assign(Object.assign({ getCoreRowModel: getCoreRowModel(), getExpandedRowModel: getExpandedRowModel(), getFacetedRowModel: getFacetedRowModel(), getFilteredRowModel: getFilteredRowModel(), getGroupedRowModel: getGroupedRowModel(), getPaginationRowModel: getPaginationRowModel(), getSortedRowModel: getSortedRowModel(), onColumnOrderChange: setColumnOrder, onGroupingChange: setGrouping, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows }, props2), {
    columns: columnDefs,
    data,
    globalFilterFn: (_v = (_u = props2.filterFns) === null || _u === void 0 ? void 0 : _u[globalFilterFn]) !== null && _v !== void 0 ? _v : (_w = props2.filterFns) === null || _w === void 0 ? void 0 : _w.fuzzy,
    initialState,
    state: Object.assign({
      columnFilterFns,
      columnOrder,
      density,
      draggingColumn,
      draggingRow,
      editingCell,
      editingRow,
      globalFilterFn,
      grouping,
      hoveredColumn,
      hoveredRow,
      isFullScreen,
      showAlertBanner,
      showColumnFilters,
      showGlobalFilter
    }, props2.state)
  }))), { refs: {
    bottomToolbarRef,
    editInputRefs,
    filterInputRefs,
    searchInputRef,
    tableContainerRef,
    tableHeadCellRefs,
    tablePaperRef,
    topToolbarRef
  }, setColumnFilterFns: (_x = props2.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns, setDensity: (_y = props2.onDensityChange) !== null && _y !== void 0 ? _y : setDensity, setDraggingColumn: (_z = props2.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn, setDraggingRow: (_0 = props2.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow, setEditingCell: (_1 = props2.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell, setEditingRow: (_2 = props2.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow, setGlobalFilterFn: (_3 = props2.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn, setHoveredColumn: (_4 = props2.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn, setHoveredRow: (_5 = props2.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow, setIsFullScreen: (_6 = props2.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen, setShowAlertBanner: (_7 = props2.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner, setShowFilters: (_8 = props2.onShowFiltersChange) !== null && _8 !== void 0 ? _8 : setShowFilters, setShowGlobalFilter: (_9 = props2.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter });
  if (props2.tableInstanceRef) {
    props2.tableInstanceRef.current = table;
  }
  const initialBodyHeight = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    if (typeof window !== "undefined") {
      initialBodyHeight.current = document.body.style.height;
    }
  }, []);
  (0, import_react2.useEffect)(() => {
    if (typeof window !== "undefined") {
      if (table.getState().isFullScreen) {
        document.body.style.height = "100vh";
      } else {
        document.body.style.height = initialBodyHeight.current;
      }
    }
  }, [table.getState().isFullScreen]);
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      Dialog_default,
      { PaperComponent: Box_default, TransitionComponent: Grow_default, disablePortal: true, fullScreen: true, keepMounted: false, onClose: () => table.setIsFullScreen(false), open: table.getState().isFullScreen, transitionDuration: 400 },
      import_react2.default.createElement(MRT_TablePaper, { table })
    ),
    !table.getState().isFullScreen && import_react2.default.createElement(MRT_TablePaper, { table }),
    editingRow && props2.editingMode === "modal" && import_react2.default.createElement(MRT_EditRowModal, { row: editingRow, table, open: true })
  );
};
var MRT_Localization_EN = {
  actions: "Actions",
  and: "and",
  cancel: "Cancel",
  changeFilterMode: "Change filter mode",
  changeSearchMode: "Change search mode",
  clearFilter: "Clear filter",
  clearSearch: "Clear search",
  clearSort: "Clear sort",
  clickToCopy: "Click to copy",
  columnActions: "Column Actions",
  copiedToClipboard: "Copied to clipboard",
  dropToGroupBy: "Drop to group by {column}",
  edit: "Edit",
  expand: "Expand",
  expandAll: "Expand all",
  filterArrIncludes: "Includes",
  filterArrIncludesAll: "Includes all",
  filterArrIncludesSome: "Includes",
  filterBetween: "Between",
  filterBetweenInclusive: "Between Inclusive",
  filterByColumn: "Filter by {column}",
  filterContains: "Contains",
  filterEmpty: "Empty",
  filterEndsWith: "Ends With",
  filterEquals: "Equals",
  filterEqualsString: "Equals",
  filterFuzzy: "Fuzzy",
  filterGreaterThan: "Greater Than",
  filterGreaterThanOrEqualTo: "Greater Than Or Equal To",
  filterInNumberRange: "Between",
  filterIncludesString: "Contains",
  filterIncludesStringSensitive: "Contains",
  filterLessThan: "Less Than",
  filterLessThanOrEqualTo: "Less Than Or Equal To",
  filterMode: "Filter Mode: {filterType}",
  filterNotEmpty: "Not Empty",
  filterNotEquals: "Not Equals",
  filterStartsWith: "Starts With",
  filterWeakEquals: "Equals",
  filteringByColumn: "Filtering by {column} - {filterType} {filterValue}",
  goToFirstPage: "Go to first page",
  goToLastPage: "Go to last page",
  goToNextPage: "Go to next page",
  goToPreviousPage: "Go to previous page",
  grab: "Grab",
  groupByColumn: "Group by {column}",
  groupedBy: "Grouped by ",
  hideAll: "Hide all",
  hideColumn: "Hide {column} column",
  max: "Max",
  min: "Min",
  move: "Move",
  noRecordsToDisplay: "No records to display",
  noResultsFound: "No results found",
  of: "of",
  or: "or",
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  resetColumnSize: "Reset column size",
  resetOrder: "Reset order",
  rowActions: "Row Actions",
  rowNumber: "#",
  rowNumbers: "Row Numbers",
  rowsPerPage: "Rows per page",
  save: "Save",
  search: "Search",
  selectedCountOfRowCountRowsSelected: "{selectedCount} of {rowCount} row(s) selected",
  select: "Select",
  showAll: "Show all",
  showAllColumns: "Show all columns",
  showHideColumns: "Show/Hide columns",
  showHideFilters: "Show/Hide filters",
  showHideSearch: "Show/Hide search",
  sortByColumnAsc: "Sort by {column} ascending",
  sortByColumnDesc: "Sort by {column} descending",
  sortedByColumnAsc: "Sorted by {column} ascending",
  sortedByColumnDesc: "Sorted by {column} descending",
  thenBy: ", then by ",
  toggleDensity: "Toggle density",
  toggleFullScreen: "Toggle full screen",
  toggleSelectAll: "Toggle select all",
  toggleSelectRow: "Toggle select row",
  toggleVisibility: "Toggle visibility",
  ungroupByColumn: "Ungroup by {column}",
  unpin: "Unpin",
  unpinAll: "Unpin all",
  unsorted: "Unsorted"
};
var MaterialReactTable = (_a) => {
  var { aggregationFns: aggregationFns2, autoResetExpanded = false, columnResizeMode = "onEnd", defaultColumn, defaultDisplayColumn, editingMode = "modal", enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnResizing = false, enableDensityToggle = true, enableExpandAll = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enablePinning = false, enableRowSelection = false, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns: filterFns2, icons, localization, positionActionsColumn = "first", positionExpandColumn = "first", positionGlobalFilter = "right", positionPagination = "bottom", positionToolbarAlertBanner = "top", positionToolbarDropZone = "top", rowNumberMode = "original", selectAllMode = "page", sortingFns: sortingFns2 } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnResizeMode", "defaultColumn", "defaultDisplayColumn", "editingMode", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnResizing", "enableDensityToggle", "enableExpandAll", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enablePinning", "enableRowSelection", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "localization", "positionActionsColumn", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberMode", "selectAllMode", "sortingFns"]);
  const _icons = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_Default_Icons), icons), []);
  const _localization = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_Localization_EN), localization), [localization]);
  const _aggregationFns = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns2), []);
  const _filterFns = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_FilterFns), filterFns2), []);
  const _sortingFns = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_SortingFns), sortingFns2), []);
  const _defaultColumn = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn), []);
  const _defaultDisplayColumn = (0, import_react2.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn), []);
  return import_react2.default.createElement(MRT_TableRoot, Object.assign({ aggregationFns: _aggregationFns, autoResetExpanded, columnResizeMode, defaultColumn: _defaultColumn, defaultDisplayColumn: _defaultDisplayColumn, editingMode, enableBottomToolbar, enableColumnActions, enableColumnFilters, enableColumnOrdering, enableColumnResizing, enableDensityToggle, enableExpandAll, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableGlobalFilterRankedResults, enableGrouping, enableHiding, enableMultiRowSelection, enableMultiSort, enablePagination, enablePinning, enableRowSelection, enableSelectAll, enableSorting, enableStickyHeader, enableTableFooter, enableTableHead, enableToolbarInternalActions, enableTopToolbar, filterFns: _filterFns, icons: _icons, localization: _localization, positionActionsColumn, positionExpandColumn, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, rowNumberMode, selectAllMode, sortingFns: _sortingFns }, rest));
};

// dep:material-react-table
var material_react_table_default = MaterialReactTable;
export {
  MRT_CopyButton,
  MRT_FilterOptionMenu,
  MRT_FullScreenToggleButton,
  MRT_GlobalFilterTextField,
  MRT_ShowHideColumnsButton,
  MRT_TablePagination,
  MRT_ToggleDensePaddingButton,
  MRT_ToggleFiltersButton,
  MRT_ToggleGlobalFilterButton,
  MRT_ToolbarInternalButtons,
  material_react_table_default as default
};
/**
 * @name match-sorter
 * @license MIT license.
 * @copyright (c) 2099 Kent C. Dodds
 * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
 */
/**
 * match-sorter-utils
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * react-table
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
//# sourceMappingURL=material-react-table.js.map
